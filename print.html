<!DOCTYPE HTML>
<html lang="zh-cmn-Hans" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>hamflx&#x27;s blog</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="css/custom.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">个人学习分享</a></li><li class="chapter-item expanded affix "><li class="part-title">文章清单</li><li class="chapter-item expanded "><a href="posts/2023/2/28/call-net-from-rust-statically.html"><strong aria-hidden="true">1.</strong> 静态链接 C# 到 Rust</a></li><li class="chapter-item expanded "><a href="posts/2022/4/26/forward-dll.html"><strong aria-hidden="true">2.</strong> 使用 Rust 编写转发 DLL</a></li><li class="chapter-item expanded "><a href="posts/2021/11/23/vite-compatibility.html"><strong aria-hidden="true">3.</strong> vite 兼容性踩坑记录</a></li><li class="chapter-item expanded "><a href="posts/2021/10/14/fe-ffmpeg.html"><strong aria-hidden="true">4.</strong> 前端通过 ffmpeg 库播放视频</a></li><li class="chapter-item expanded "><a href="posts/2021/5/15/my-wordpress-config.html"><strong aria-hidden="true">5.</strong> 又一个 WordPress 博客的初始配置</a></li><li class="chapter-item expanded "><a href="posts/2021/1/24/element-memory-leak.html"><strong aria-hidden="true">6.</strong> 记一次内存泄漏的排查过程</a></li><li class="chapter-item expanded "><a href="posts/2020/11/13/vsc-vue-intelli-sense.html"><strong aria-hidden="true">7.</strong> 增强 Vue 项目的智能感知</a></li><li class="chapter-item expanded "><a href="posts/2020/11/13/vuedraggable-usage.html"><strong aria-hidden="true">8.</strong> vuedraggable 使用问题记录</a></li><li class="chapter-item expanded "><a href="posts/2019/3/22/dst-server.html"><strong aria-hidden="true">9.</strong> 玩饥荒联机版日志</a></li><li class="chapter-item expanded "><a href="posts/2023/2/11/fetch-browser.html"><strong aria-hidden="true">10.</strong> Chrome 时代的浏览器兼容性测试</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">hamflx&#x27;s blog</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="个人学习分享"><a class="header" href="#个人学习分享">个人学习分享</a></h1>
<p>暂无。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="静态链接-c-到-rust"><a class="header" href="#静态链接-c-到-rust">静态链接 C# 到 Rust</a></h1>
<p>最近 <code>.Net 7</code> 发布之后，因为带了 <code>AOT</code> 编译器，又爆发了一波热度，正好我最近有需求需要使用到这个功能，本文就记录下如何实现将 <code>.Net 7</code> 库编译成静态库，然后用 <code>Rust</code> 链接。</p>
<p>本文实现的是将一个非标准的 <code>DES</code> 算法编译成静态库，供 <code>Rust</code> 调用。该 <code>DES</code> 算法的 <code>C#</code> 实现在这里可以找到：<a href="https://github.com/fygroup/Security/blob/master/DES.cs">https://github.com/fygroup/Security/blob/master/DES.cs</a>。</p>
<p>本文项目的目录结构为：</p>
<pre><code class="language-plaintext">./call-net-from-rust-statically
  ├── des-lib
  │   ├── des-lib.csproj
  │   └── DES.cs
  ├── Cargo.toml
  ├── build.rs
  └── src
      └── main.rs
</code></pre>
<p>先创建好 <code>call-net-from-rust-statically</code> 目录：</p>
<pre><code class="language-powershell">mkdir call-net-from-rust-statically
</code></pre>
<h2 id="c-项目部分"><a class="header" href="#c-项目部分">C# 项目部分</a></h2>
<p>首先创建项目：</p>
<pre><code class="language-powershell">cd call-net-from-rust-statically
dotnet new classlib -n des-lib
</code></pre>
<p>将 <code>Class1.cs</code> 重命名为 <code>DES.cs</code>，然后把上面链接中的 <code>DES</code> 类复制到 <code>DES.cs</code> 中，改下命名空间，再加上导出函数的代码，如下：</p>
<pre><code class="language-csharp">namespace des_lib;

using System.Runtime.InteropServices;

public class DES
{
  [UnmanagedCallersOnly(EntryPoint = &quot;wtf_des_encrypt&quot;)]
  public static nint FFI_Encrypt(nint message, nint key)
  {
    var managedMessage = Marshal.PtrToStringUTF8(message);
    var managedKey = Marshal.PtrToStringUTF8(key);
    if (managedKey == null || managedMessage == null)
    {
      return nint.Zero;
    }
    var cipherText = EncryptDES(managedMessage, managedKey);
    return Marshal.StringToHGlobalAnsi(cipherText);
  }

  [UnmanagedCallersOnly(EntryPoint = &quot;wtf_des_decrypt&quot;)]
  public static nint FFI_Decrypt(nint cipherMessage, nint key)
  {
    var managedCipherMessage = Marshal.PtrToStringUTF8(cipherMessage);
    var managedKey = Marshal.PtrToStringUTF8(key);
    if (managedKey == null || managedCipherMessage == null)
    {
      return nint.Zero;
    }
    var plainText = DecryptDES(managedCipherMessage, managedKey);
    return Marshal.StringToHGlobalAnsi(plainText);
  }

  [UnmanagedCallersOnly(EntryPoint = &quot;wtf_des_free&quot;)]
  public static void FFI_FreeMemory(nint buffer)
  {
    Marshal.FreeHGlobal(buffer);
  }

  // 将原有 DES 类的内容放在这里。
}
</code></pre>
<p>其中 <code>wtf_des_encrypt</code>、<code>wtf_des_decrypt</code> 和 <code>wtf_des_free</code> 就是导出的加密、解密以及释放内存的方法。</p>
<p>配置项目的属性：</p>
<pre><code class="language-xml">&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

  &lt;PropertyGroup&gt;
    &lt;TargetFramework&gt;net7.0&lt;/TargetFramework&gt;
    &lt;NativeLib&gt;Static&lt;/NativeLib&gt;
    &lt;PublishAot&gt;true&lt;/PublishAot&gt;
    &lt;StripSymbols&gt;true&lt;/StripSymbols&gt;
    &lt;SelfContained&gt;true&lt;/SelfContained&gt;
  &lt;/PropertyGroup&gt;

&lt;/Project&gt;
</code></pre>
<p>然后就可以用如下命令编译一下试试看：</p>
<pre><code class="language-powershell">cd des-lib
dotnet publish -r win-x64 -c Release
</code></pre>
<p>在构建完毕之后，会在 <code>bin\Release\net7.0\win-x64\publish</code> 目录下生成 <code>des-lib.lib</code> 文件。</p>
<h2 id="rust-项目部分"><a class="header" href="#rust-项目部分">Rust 项目部分</a></h2>
<p>在上面的项目构建成功后，将会把 <code>ilcompiler</code> 包缓存，并可以在该目录 <code>%USERPROFILE%/.nuget/packages/runtime.win-x64.microsoft.dotnet.ilcompiler/7.0.1/sdk</code> 找到链接依赖的一些静态库（注意，版本号可能会变更）。</p>
<p>在 <code>call-net-from-rust-statically</code> 目录中创建 <code>Rust</code> 项目：</p>
<pre><code class="language-powershell">cd call-net-from-rust-statically
cargo init
</code></pre>
<p>先添加 <code>windows</code> 依赖，这是因为在链接的时候，<code>.Net</code> 运行时会依赖 <code>Win32 API</code>：</p>
<pre><code class="language-powershell">cargo add windows
</code></pre>
<p>添加 <code>build.rs</code>，一定要注意修改 <code>sdk_path</code> 中的 <code>ilcompiler</code> 版本号（本文讲的是实现步骤，最终的代码我会把 <code>des-lib</code> 的构建也放在 <code>build.rs</code> 中，并从构建的输出中寻找这个版本号，而不需要写死）：</p>
<pre><pre class="playground"><code class="language-rust">use std::path::PathBuf;

fn main() {
    let user_profile: PathBuf = std::env::var(&quot;USERPROFILE&quot;).unwrap().into();
    let sdk_path: PathBuf = (user_profile)
        .join(&quot;.nuget\\packages\\runtime.win-x64.microsoft.dotnet.ilcompiler\\7.0.1\\sdk&quot;);
    let manifest_dir: PathBuf = std::env::var(&quot;CARGO_MANIFEST_DIR&quot;).unwrap().into();
    let des_lib_path = manifest_dir.join(&quot;des-lib&quot;);

    println!(&quot;cargo:rustc-link-arg=/INCLUDE:NativeAOT_StaticInitialization&quot;);
    println!(&quot;cargo:rustc-link-search={}&quot;, sdk_path.display());
    println!(
        &quot;cargo:rustc-link-search={}\\bin\\Release\\net7.0\\win-x64\\publish&quot;,
        des_lib_path.display()
    );

    println!(&quot;cargo:rustc-link-lib=static=windows&quot;);
    println!(&quot;cargo:rustc-link-lib=static=bootstrapperdll&quot;);
    println!(&quot;cargo:rustc-link-lib=static=Runtime.WorkstationGC&quot;);
    println!(&quot;cargo:rustc-link-lib=static=System.Globalization.Native.Aot&quot;);
    println!(&quot;cargo:rustc-link-lib=static=des-lib&quot;);
}</code></pre></pre>
<p>接下来就是调用了，在 <code>main.rs</code> 中添加：</p>
<pre><pre class="playground"><code class="language-rust">extern &quot;C&quot; {
    fn wtf_des_encrypt(message: *const u8, key: *const u8) -&gt; *const u8;
    fn wtf_des_decrypt(cipher_text: *const u8, key: *const u8) -&gt; *const u8;
    fn wtf_des_free(ptr: *const u8);
}

fn main() {
    let key = b&quot;key\0&quot;;
    let cipher_text = unsafe { wtf_des_encrypt(b&quot;message\0&quot;.as_ptr(), key.as_ptr()) };
    let cipher_text = unsafe { std::ffi::CStr::from_ptr(cipher_text as *const i8) };
    let plain_text = unsafe { wtf_des_decrypt(cipher_text.as_ptr() as _, key.as_ptr()) };
    let plain_text = unsafe { std::ffi::CStr::from_ptr(plain_text as *const i8) };
    println!(&quot;cipher_text: {}&quot;, cipher_text.to_str().unwrap());
    println!(&quot;plain_text: {}&quot;, plain_text.to_str().unwrap());

    unsafe {
        wtf_des_free(cipher_text.as_ptr() as _);
        wtf_des_free(plain_text.as_ptr() as _);
    }
}</code></pre></pre>
<h2 id="最终版本"><a class="header" href="#最终版本">最终版本</a></h2>
<p>仓库地址：<a href="https://github.com/hamflx/call-net-from-rust-statically">https://github.com/hamflx/call-net-from-rust-statically</a>，在本文的基础增加了自动构建 <code>C#</code> 项目，自动查找 <code>ilcompiler</code> 的路径并链接。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用-rust-编写转发-dll"><a class="header" href="#使用-rust-编写转发-dll">使用 Rust 编写转发 DLL</a></h1>
<p>本文实现一个转发 DLL：<code>version.dll</code> 转发到系统的 <code>version.dll</code> 上。另外要注意，本文代码仅供参考，不一定可以运行，需要做一定的修改，或直接查看最终实现：<a href="https://github.com/hamflx/forward-dll">https://github.com/hamflx/forward-dll</a>。</p>
<p>首先用下面的命令查看系统的 <code>version.dll</code> 导出函数：</p>
<pre><code class="language-plain">C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise&gt;dumpbin /exports c:\windows\system32\version.dll
Microsoft (R) COFF/PE Dumper Version 14.29.30136.0
Copyright (C) Microsoft Corporation.  All rights reserved.


Dump of file c:\windows\system32\version.dll

File Type: DLL

  Section contains the following exports for VERSION.dll

    00000000 characteristics
    927B71E6 time date stamp
        0.00 version
           1 ordinal base
          17 number of functions
          17 number of names

    ordinal hint RVA      name

          1    0 00001080 GetFileVersionInfoA
          2    1 00002190 GetFileVersionInfoByHandle
          3    2 00001DF0 GetFileVersionInfoExA
          4    3 00001040 GetFileVersionInfoExW
          5    4 00001010 GetFileVersionInfoSizeA
          6    5 00001E00 GetFileVersionInfoSizeExA
          7    6 00001050 GetFileVersionInfoSizeExW
          8    7 00001060 GetFileVersionInfoSizeW
          9    8 00001070 GetFileVersionInfoW
         10    9 00001E10 VerFindFileA
         11    A 00002360 VerFindFileW
         12    B 00001E20 VerInstallFileA
         13    C 00002F80 VerInstallFileW
         14    D          VerLanguageNameA (forwarded to KERNEL32.VerLanguageNameA)
         15    E          VerLanguageNameW (forwarded to KERNEL32.VerLanguageNameW)
         16    F 00001020 VerQueryValueA
         17   10 00001030 VerQueryValueW

  Summary

        1000 .data
        1000 .pdata
        2000 .rdata
        1000 .reloc
        1000 .rsrc
        3000 .text

C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise&gt;
</code></pre>
<p>然后我们拿 <code>GetFileVersionInfoSizeA</code> 举例来写一个实例函数：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static mut RealGetFileVersionInfoSizeA: usize = 0;

#[no_mangle]
pub extern &quot;system&quot; fn GetFileVersionInfoSizeA() -&gt; u32 {
    unsafe {
        std::arch::asm!(
            &quot;jmp rax&quot;,
            in(&quot;rax&quot;) RealGetFileVersionInfoSizeA,
            options(nostack)
        );
    }
    1
}
<span class="boring">}</span></code></pre></pre>
<p>这个函数其实也不能叫函数，因为它不会返回，直接跳转到目标函数地址，这个目标函数地址需要在 <code>DllMain</code> 中通过 <code>LoadLibrary</code> 和 <code>GetProcAddress</code> 进行赋值：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern &quot;system&quot; fn DllMain(_inst: isize, reason: u32, _: *const u8) -&gt; u32 {
    if reason == 1 {
        let version_module = load_library(&quot;c:\\windows\\system32\\version.dll&quot;);
        unsafe { RealGetFileVersionInfoSizeA = get_proc_address(version_module, &quot;GetFileVersionInfoSizeA&quot;) };
    }
    1
}
<span class="boring">}</span></code></pre></pre>
<p>如果每个函数都这么写，那是相当的麻烦，因此，我们可以写一个宏，并把加载目标 dll 的真实地址封装到结构体的方法里面，这样在 <code>DllMain</code> 时直接调用即可：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export]
macro_rules! forward_dll {
    ($lib:expr, $name:ident, $($proc:ident)*) =&gt; {
        static mut $name: forward_dll::DllForwarder&lt;{ forward_dll::count!($($proc)*) }&gt; = forward_dll::DllForwarder {
            lib_name: $lib,
            target_functions_address: [
                0;
                forward_dll::count!($($proc)*)
            ],
            target_function_names: [
                $(stringify!($proc),)*
            ]
        };
        forward_dll::define_function!($name, 0, $($proc)*);
    };
}

#[macro_export]
macro_rules! define_function {
    ($name:ident, $index:expr, ) =&gt; {};
    ($name:ident, $index:expr, $proc:ident $($procs:ident)*) =&gt; {
        #[no_mangle]
        pub extern &quot;system&quot; fn $proc() -&gt; u32 {
            unsafe {
                std::arch::asm!(
                    &quot;jmp rax&quot;,
                    in(&quot;rax&quot;) $name.target_functions_address[$index],
                    options(nostack)
                );
            }
            1
        }
        forward_dll::define_function!($name, ($index + 1), $($procs)*);
    };
}

/// DLL 转发类型的具体实现。该类型不要自己实例化，应调用 forward_dll 宏生成具体的实例。
pub struct DllForwarder&lt;const N: usize&gt; {
    pub target_functions_address: [usize; N],
    pub target_function_names: [&amp;'static str; N],
    pub lib_name: &amp;'static str,
}

impl&lt;const N: usize&gt; DllForwarder&lt;N&gt; {
    /// 将所有函数的跳转地址设置为对应的 DLL 的同名函数地址。
    pub fn forward_all(&amp;mut self) -&gt; ForwardResult&lt;()&gt; {
        let load_module_dir = &quot;C:\\Windows\\System32\\&quot;;
        let module_full_path = format!(&quot;{}{}&quot;, load_module_dir, self.lib_name);
        let module_handle = get_module_handle(module_full_path.as_str())?;

        for index in 0..self.target_functions_address.len() {
            let addr_in_remote_module =
                get_proc_address_by_module(module_handle, self.target_function_names[index])?;
            self.target_functions_address[index] = addr_in_remote_module as *const usize as usize;
        }

        Ok(())
    }
}

forward_dll::forward_dll!(
    &quot;C:\\Windows\\system32\\version.dll&quot;,
    DLL_VERSION_FORWARDER,
    GetFileVersionInfoA
    GetFileVersionInfoByHandle
    GetFileVersionInfoExA
    GetFileVersionInfoExW
    GetFileVersionInfoSizeA
    GetFileVersionInfoSizeExA
    GetFileVersionInfoSizeExW
    GetFileVersionInfoSizeW
    GetFileVersionInfoW
    VerFindFileA
    VerFindFileW
    VerInstallFileA
    VerInstallFileW
    VerLanguageNameA
    VerLanguageNameW
    VerQueryValueA
    VerQueryValueW
);

// 在 DllMain 中调用：
// unsafe { DLL_VERSION_FORWARDER.forward_all() };
<span class="boring">}</span></code></pre></pre>
<p>这就完成了 <code>version.dll</code> 的转发。可参考通过该方法实现的一个小工具：<a href="https://github.com/hamflx/huawei-pc-manager-bootstrap">https://github.com/hamflx/huawei-pc-manager-bootstrap</a>。</p>
<h2 id="法二"><a class="header" href="#法二">法二</a></h2>
<p>如果我们不希望通过 <code>DllMain</code> 来初始化怎么办？我们可以在跳板函数里面加载目标函数地址，为了保证寄存器和栈上数据的状态，我们单独写一个加载函数，并从跳板里面调用过去，由编译器来帮我们保证寄存器的状态。</p>
<p>通过该函数拿到目标函数地址后将其返回，那么目标函数地址就存储在 <code>rax</code> 上，然后再跳转到 <code>rax</code> 上：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub extern &quot;system&quot; fn $proc() -&gt; u32 {
    unsafe {
        std::arch::asm!(
            &quot;push rcx&quot;,
            &quot;push rdx&quot;,
            &quot;push r8&quot;,
            &quot;push r9&quot;,
            &quot;push r10&quot;,
            &quot;push r11&quot;,
            options(nostack)
        );
        std::arch::asm!(
            &quot;sub rsp, 28h&quot;,
            &quot;call rax&quot;,
            &quot;add rsp, 28h&quot;,
            in(&quot;rax&quot;) forward_dll::default_jumper,
            in(&quot;rcx&quot;) std::concat!($lib, &quot;\0&quot;).as_ptr() as usize,
            in(&quot;rdx&quot;) std::concat!(std::stringify!($proc), &quot;\0&quot;).as_ptr() as usize,
            options(nostack)
        );
        std::arch::asm!(
            &quot;pop r11&quot;,
            &quot;pop r10&quot;,
            &quot;pop r9&quot;,
            &quot;pop r8&quot;,
            &quot;pop rdx&quot;,
            &quot;pop rcx&quot;,
            &quot;jmp rax&quot;,
            options(nostack)
        );
    }
    1
}
<span class="boring">}</span></code></pre></pre>
<p>然后我们实现一个 <code>forward_dll::default_jumper</code> 方法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 默认的跳板，如果没有执行初始化操作，则进入该函数。
pub fn default_jumper(
    lib_name: *const u8,
    func_name: *const u8,
) -&gt; usize {
    let module_handle = unsafe { LoadLibraryA(lib_name) };
    if module_handle != 0 {
        let addr = unsafe { GetProcAddress(module_handle, func_name) };
        // 这里调用了 FreeLibrary 释放目标模块，实际使用需要在其他地方持有目标模块的句柄，防止被释放。
        unsafe { FreeLibrary(module_handle) };
        return addr.map(|addr| addr as usize).unwrap_or(exit_fn as usize);
    }

    exit_fn as usize
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vite-兼容性踩坑记录"><a class="header" href="#vite-兼容性踩坑记录">vite 兼容性踩坑记录</a></h1>
<p>vite 提供的快速启动开发模式服务器的特性非常好用，不过，有时候线上出了兼容性问题，你还无法快速定位到问题的根源，那就需要低版本的浏览器来进行开发测试，然而……</p>
<p>想要在低版本浏览器上运行项目，首先要在浏览器上打开项目，因为我们项目采用了可选链，导致连项目都打不开。</p>
<p>尝试配置 <code>config.esbuild.target</code> 为 <code>es2015</code>，ts 文件是可以被正确编译了，但是 vue 文件仍然不行，然后我去搜索，发现了好多人都有这个问题，但是貌似没有一个能给出很方便的解决方案的。在 GitHub 上有个 issue 给出了 PR，但是这个 PR 没有被合并（issue：<a href="https://github.com/vitejs/vite/issues/5222" title="https://github.com/vitejs/vite/issues/5222">https://github.com/vitejs/vite/issues/5222</a>，pr：<a href="https://github.com/vitejs/vite/pull/5652" title="https://github.com/vitejs/vite/pull/5652">https://github.com/vitejs/vite/pull/5652</a>）。</p>
<p>根据上面的 pr 我们可以看到 <code>plugin-vue</code> 的源代码，发现 vue 中的 ts 是不检查 <code>config.esbuild.target</code> 选项的，如下图：</p>
<p><img src="posts/2021/11/23/./assets/image_0QLmJMwi1A.png" alt="transformWithEsBuild" title="transformWithEsBuild" /></p>
<p>所以我首先尝试的方法就是按照 PR 所述直接修改 node_modules 里的文件，改完之后发现 vue 中的可选链被编译了，但是 ts 中的可选链仍然没有被编译，这个时候再搭配一下 <code>config.esbuild.target</code> 就能把两边问题都给解决了，不过这个方法要修改 node_modules 不太好。</p>
<p>后来换了 <code>@rollup/plugin-babel</code> 插件，配置完也不行，研究了下源代码，对于 ts 项目，需要配置 extensions 才行：</p>
<pre><code class="language-javascript">export const DEFAULT_EXTENSIONS: ['.js', '.jsx', '.es6', '.es', '.mjs'];

const unpackOptions = ({
  extensions = babel.DEFAULT_EXTENSIONS,
  // rollup uses sourcemap, babel uses sourceMaps
  // just normalize them here so people don't have to worry about it
  sourcemap = true,
  sourcemaps = true,
  sourceMap = true,
  sourceMaps = true,
  ...rest
} = {}) =&gt; {
  return {
    extensions,
    plugins: [],
    sourceMaps: sourcemap &amp;&amp; sourcemaps &amp;&amp; sourceMap &amp;&amp; sourceMaps,
    ...rest,
    caller: {
      name: '@rollup/plugin-babel',
      ...rest.caller
    }
  };
};
</code></pre>
<p>配置如下：</p>
<pre><code class="language-javascript">import { resolve } from 'path'
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import babel from '@rollup/plugin-babel'

export default defineConfig({
  plugins: [
    vue(),
    babel({
      extensions: ['.ts', '.js', '.jsx', '.es6', '.es', '.mjs'],
      plugins: [
        '@babel/plugin-proposal-optional-chaining',
        '@babel/plugin-proposal-nullish-coalescing-operator'
      ]
    })
  ]
})
</code></pre>
<p>一眼看过去发现应该还是不行，因为缺少 <code>.vue</code> 文件的处理，试了一下果然不行，不过，扩展名里加 <code>.vue</code> 的话会报错，一般来说 <code>.vue</code> 文件编译之后会是 js，但是 <code>.vue</code> 里面如果包含了样式，会单独提取出来作为一个虚拟的文件，通过查询参数 <code>type=style</code> 来读取，这里以 <code>babel</code> 来转译样式文件当然报错。</p>
<p>看了下 <code>@rollup/plugin-babel</code> 的代码，发现还有 <code>include/exclude/filter</code> 选项可以使用，与扩展名之间是且的关系：</p>
<pre><code class="language-javascript">const userDefinedFilter =
  typeof customFilter === 'function' ? customFilter : createFilter(include, exclude);
filter = (id) =&gt; extensionRegExp.test(stripQuery(id).bareId) &amp;&amp; userDefinedFilter(id);
</code></pre>
<p>所以，我们只要限定一下，只转义以 <code>.vue</code> 为后缀的文件就行了：</p>
<pre><code class="language-javascript">import { resolve } from 'path'
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import babel from '@rollup/plugin-babel'

export default defineConfig({
  plugins: [
    vue(),
    babel({
      include: [
        /\.vue$/,
        /\.ts$/
      ],
      extensions: ['.vue', '.ts', '.js'],
      plugins: [
        '@babel/plugin-proposal-optional-chaining',
        '@babel/plugin-proposal-nullish-coalescing-operator'
      ]
    })
  ]
})
</code></pre>
<p>最后结果如下：</p>
<p><img src="posts/2021/11/23/./assets/image_2sI2iMOtJM.png" alt="转译结果" title="转译结果" /></p>
<p>为了解决 <code>chrome</code> 的滚动条 <code>bug</code>（另外再吐槽下，最近 <code>chrome</code> 频繁升级导致的 <code>bug</code> 真的是不少），先得把 <code>vite</code> 不支持 <code>chrome</code> 老版本的问题解决……</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="前端通过-ffmpeg-库播放视频"><a class="header" href="#前端通过-ffmpeg-库播放视频">前端通过 ffmpeg 库播放视频</a></h1>
<p>仓库地址：<a href="https://github.com/hamflx/ffmpeg-fe">https://github.com/hamflx/ffmpeg-fe</a></p>
<p>先看一下 <code>chrome</code> 支持的视频格式与解码器：</p>
<p><img src="posts/2021/10/14/./assets/codec-and-container-support.png" alt="Codec and Container Support" title="Codec and Container Support" /></p>
<p>其中 <code>H.265</code> 并不在一般的 <code>Chrome</code> 上支持，有时候我们需要播放一些不常用的格式，那么我们就可以将 <code>ffmpeg</code> 库编译为 <code>WebAssembly</code> 以支持这些格式。</p>
<p><code>ffmpeg</code> 是一个音视频处理的通用库，我们需要用 <code>C++</code> 写一个调用 <code>ffmpeg</code> 的解码程序，该程序与 <code>JS</code> 进行通信，取得视频数据，并调用 <code>ffmpeg</code> 解码，将解码后的程序送给 <code>JS</code>，由 <code>JS</code> 调用 <code>WebGL</code> 渲染。</p>
<p><img src="posts/2021/10/14/./assets/program-structure.png" alt="程序结构" title="程序结构" /></p>
<p>我这里以流的形式来取视频数据、解码，在播放器一侧在 <code>requestAnimationFrame</code> 中拉取视频数据：</p>
<p><img src="posts/2021/10/14/./assets/program-sequence.png" alt="时序图" title="时序图" /></p>
<h2 id="构建-ffmpeg-库"><a class="header" href="#构建-ffmpeg-库">构建 <code>ffmpeg</code> 库</a></h2>
<p>首先需要把 <code>ffmpeg</code> 编译成几个库，后续我们的 <code>C++</code> 解码程序就可以调用这个库里的方法，构建命令：</p>
<pre><code class="language-shell">CPPFLAGS=&quot;-D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600&quot; \
emconfigure ./configure \
    --prefix=$(pwd)/lib \
    --cc=&quot;emcc&quot; \
    --cxx=&quot;em++&quot; \
    --ar=&quot;emar&quot; \
    --ranlib=&quot;emranlib&quot; \
    --target-os=none \
    --enable-cross-compile \
    --enable-lto \
    --cpu=generic \
    --arch=x86_64 \
    --disable-asm \
    --disable-inline-asm \
    --disable-programs \
    --disable-avdevice \
    --disable-doc \
    --disable-swresample \
    --disable-postproc  \
    --disable-avfilter \
    --disable-pthreads \
    --disable-w32threads \
    --disable-os2threads \
    --disable-network \
    --disable-logging \
    --disable-everything \
    --enable-gpl \
    --enable-version3 \
    --enable-static \
    --enable-demuxers \
    --enable-parsers \
    --enable-decoder=pcm_mulaw \
    --enable-decoder=pcm_alaw \
    --enable-decoder=adpcm_ima_smjpeg \
    --enable-protocol=file \
    --enable-protocol=pipe \
    --enable-decoder=h264 \
    --enable-decoder=hevc

make &amp;&amp; make install
</code></pre>
<p>以上构建命令成功后，将会得到下面的文件：</p>
<p><img src="posts/2021/10/14/./assets/build-artifacts.png" alt="lib*.a" title="lib*.a" /></p>
<h2 id="编写解码程序"><a class="header" href="#编写解码程序">编写解码程序</a></h2>
<p>通过 <code>ffmpeg</code> 的自定义流，来实现一个 <code>read_packet</code> 方法，该方法内部调用 <code>js</code> 的异步方法取得视频流，以此作为输入。程序主循环中不断尝试调用 <code>avcodec_receive_frame</code> 解码，当数据不足时，通过 <code>av_read_frame</code> 和 <code>avcodec_send_packet</code> 将数据发送给 <code>ffmpeg</code> 的解码器。</p>
<p>自定义输入流如下：</p>
<pre><code class="language-cpp">int nBufferSize = 32768;
unsigned char *pReadBuffer = (unsigned char*)av_malloc(nBufferSize);
if (pReadBuffer == NULL)
{
  return DECODER_ERROR::AV_ERROR;
}

AVIOContext *pIoCtx = avio_alloc_context(pReadBuffer, nBufferSize, 0, (void*)this, DecoderReadPacket, NULL, NULL);
if (pIoCtx == NULL)
{
  return DECODER_ERROR::AV_ERROR;
}

m_pFmtCtx = avformat_alloc_context();
m_pFmtCtx-&gt;pb = pIoCtx;
m_pFmtCtx-&gt;flags = AVFMT_FLAG_CUSTOM_IO;

int ret;
while ((ret = avformat_open_input(&amp;m_pFmtCtx, NULL, NULL, NULL)) == AVERROR(EAGAIN))
{
}
if (ret)
{
  return DECODER_ERROR::AV_ERROR;
}

int Decoder::ReadPacket(void *opaque, uint8_t*buf, int buf_size)
{
  emscripten::val packet = m_jsUpstream.call&lt;emscripten::val&gt;(&quot;next&quot;, buf_size).await();
  emscripten::val data = packet[&quot;data&quot;];
  emscripten::val done = packet[&quot;done&quot;];
  if (done.as&lt;bool&gt;())
  {
    return 0;
  }

  const auto nPacketLength = data[&quot;length&quot;].as&lt;unsigned&gt;();
  if (nPacketLength &gt; buf_size)
  {
    printf(&quot;==&gt; nPacketLength &gt; buf_size\n&quot;);
  }

  emscripten::val memoryView{emscripten::typed_memory_view(nPacketLength, buf)};
  memoryView.call&lt;void&gt;(&quot;set&quot;, data.call&lt;emscripten::val&gt;(&quot;slice&quot;, 0, nPacketLength));

  return nPacketLength;
}
</code></pre>
<p>程序主循环解码（其实是在 <code>JS</code> 里调用 <code>Next</code> 到 <code>C++</code> 的）如下：</p>
<pre><code class="language-cpp">while ((ret = avcodec_receive_frame(m_pCodecCtx, m_pFrame)) == AVERROR(EAGAIN))
{
  while (1)
  {
    ret = av_read_frame(m_pFmtCtx, m_pPacketFrame);
    if (ret == 0)
    {
      if (m_pPacketFrame-&gt;stream_index == m_iVideoStream)
      {
        break;
      }
      av_packet_unref(m_pPacketFrame);
      continue;
    }

    printf(&quot;==&gt; av_read_frame error: %s\n&quot;, av_err2str(ret));
    av_packet_unref(m_pPacketFrame);

    if (ret == AVERROR_EOF)
    {
      result.set(&quot;status&quot;, (int)DECODER_ERROR::END_OF_FILE);
      return result;
    }
    if (ret != 0)
    {
      printf(&quot;av_read_frame failed: %s\n&quot;, av_err2str(ret));
      result.set(&quot;status&quot;, (int)DECODER_ERROR::AV_READ_FRAME);
      return result;
    }
  }

  ret = avcodec_send_packet(m_pCodecCtx, m_pPacketFrame);
  av_packet_unref(m_pPacketFrame);

  if (ret != 0)
  {
    printf(&quot;==&gt; avcodec_send_packet error: %s\n&quot;, av_err2str(ret));
    result.set(&quot;status&quot;, (int)DECODER_ERROR::AVCODEC_SEND_PACKET);
    return result;
  }
}
</code></pre>
<p>Makefile</p>
<pre><code class="language-makefile">all: ../web/ff.js

rebuild: clean all

CC = emcc
CFLAGS = -O3 -I../lib/include
LIBOBJS := ../lib/lib/libavcodec.a ../lib/lib/libavutil.a ../lib/lib/libavformat.a
EMCCFLAGS = -gsource-map -g --bind -s ASYNCIFY -s WASM=1 -s ALLOW_TABLE_GROWTH=1 -s ALLOW_MEMORY_GROWTH=1 -s FILESYSTEM=0 -s ASSERTIONS=1

../web/ff.js: ff.cpp $(LIBOBJS)
 $(CC) $(EMCCFLAGS) $(CFLAGS) -o $@ $^

fflib: build-ffmpeg.sh
 sh build-ffmpeg.sh

clean:
 rm -f ff.js ff.wasm
</code></pre>
<h2 id="web-端"><a class="header" href="#web-端"><code>web</code> 端</a></h2>
<p>首先要实现一个视频来源对象，主要逻辑就是在调用 <code>next</code> 方法时，将视频数据返回，同时，如果数据太多，就先缓存着：</p>
<pre><code class="language-js">async function beginReadPacket() {
  let cachedSize = 0
  /**

* @type {Uint8Array[]}
   */
  const cachedChunks = []
  const reader = (await fetch('test.mkv')).body.getReader()
  const combineChunks = size =&gt; {
    let resultSize = 0
    const result = new Uint8Array(size)
    while (resultSize &lt; size) {
      const chunk = cachedChunks.shift()
      if (chunk.length + resultSize &gt; size) {
        const needSize = size - resultSize
        result.set(chunk.slice(0, needSize), resultSize)
        resultSize += needSize
        cachedChunks.unshift(chunk.slice(needSize))
        break
      } else {
        result.set(chunk, resultSize)
        resultSize += chunk.length
      }
    }
    cachedSize -= result.length
    return result
  }
  return async size =&gt; {
    while (cachedSize &lt; size) {
      const { done, value } = await reader.read()
      if (done) {
        if (!cachedSize) return { done }
        return { data: combineChunks(cachedSize) }
      }
      cachedChunks.push(value)
      cachedSize += value.length
    }
    return { data: combineChunks(size) }
  }
}
</code></pre>
<p>然后就是在 <code>requestAnimationFrame</code> 中调用 <code>decoder.next</code> 来拉去视频帧了，就不写了。当然，最后还有一步是拿解码后的 <code>YUV</code> 数据丢给 <code>WebGL</code> 渲染，具体就不展开了。</p>
<h2 id="问题"><a class="header" href="#问题">问题</a></h2>
<p>虽然最开始是因为 <code>H.265</code> 无法播放，才去做这个东西的，但是吧，做完之后发现，就这样还真不一定能播放 <code>mp4</code> 封装的 <code>H.265</code> 视频。</p>
<p>对于 <code>mp4</code> 格式的文件信息 <code>moov</code> <code>box</code> 有可能是在文件最后的，我这里实现的方法是取视频流，一部分一部分的解码，就会导致取不到视频信息。所以对于这种视频文件，要么是把视频数据取完整了，一股脑塞进 <code>ffmpeg</code> 取识别，或者也可以把他的 <code>moov</code> <code>box</code> 放到前面，或者直接指定解码器参数也可以吧。</p>
<p>下面的命令将 <code>mp4</code> 视频的 <code>moov</code> <code>box</code> 放前面：</p>
<pre><code class="language-shell">ffmpeg -i test.mkv -c:v libx265 -preset ultrafast -c:a copy -movflags faststart test.mp4
</code></pre>
<h2 id="参考资料"><a class="header" href="#参考资料">参考资料</a></h2>
<ul>
<li><a href="https://github.com/3dgen/cppwasm-book">C/C++面向WebAssembly编程</a></li>
<li><a href="https://stackoverflow.com/questions/41734219/avformat-open-input-fails-only-with-a-custom-io-context">avformat_open_input fails only with a custom IO context</a></li>
<li><a href="https://blog.csdn.net/wowotou_heihei/article/details/115622917">avformat_open_input返回-1094995529 “Invalid data found when processing input“</a></li>
<li><a href="https://www.cnblogs.com/leisure_chn/p/10318145.html">FFmpeg内存IO模式(内存区作输入或输出)</a></li>
<li><a href="https://github.com/lightfish-zhang/mpegUtil">ffmpeg 的编程教程</a></li>
<li><a href="https://segmentfault.com/a/1190000017980746">一步步进行ffmpeg的C语言音视频编程</a></li>
<li><a href="https://segmentfault.com/a/1190000021378256">ffmpeg AVIOContext 自定义 IO 及 seek</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1669163">FFmpeg进行音频的解码和播放</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="又一个-wordpress-博客的初始配置"><a class="header" href="#又一个-wordpress-博客的初始配置">又一个 WordPress 博客的初始配置</a></h1>
<p>站点结构：<code>nginx</code> =&gt; <code>WordPress</code></p>
<h2 id="配置-https"><a class="header" href="#配置-https">配置 HTTPS</a></h2>
<pre><code class="language-conf"># 生成公私钥对
ssh-keygen ...

# 生成证书申请请求
openssl req -new -sha256 -key cert.key -subj &quot;/C=CN/ST=Anhui/L=Wuhu/O=whit/CN=hamflx.cn&quot; \
    -reqexts SAN -config &lt;(cat /etc/pki/tls/openssl.cnf \
    &lt;(printf &quot;[SAN]\nsubjectAltName=DNS:hamflx.cn,DNS:*.hamflx.cn&quot;)) \
    &gt;cert.csr

# 申请通配符证书
docker run -it --rm \
    -e DP_Id=DP_Id \
    -e DP_Key=DP_Key \
    -v $PWD:/acme.sh \
    neilpang/acme.sh \
    --signcsr \
    --csr /acme.sh/cert.csr \
    --dns dns_dp
</code></pre>
<p>强制流量从 <code>http</code> 重定向到 <code>https</code> 的 <code>nginx</code> 的配置：</p>
<pre><code class="language-conf">server {
  listen 80 default_server;
  listen [::]:80 default_server;
  server_name _;
  return 301 https://$host$request_uri;
}
</code></pre>
<h2 id="配置-http-20"><a class="header" href="#配置-http-20">配置 HTTP 2.0</a></h2>
<pre><code class="language-conf">server {
    listen       443 default_server ssl http2;
    listen  [::]:443 default_server ssl http2;
    server_name  www.hamflx.cn hamflx.cn;

    ssl_certificate     /hamflx.cn/fullchain.cer;
    ssl_certificate_key /hamflx.cn/cert.key;

    location / {
        root   /usr/share/nginx/html;
        index  index.html index.htm;

        # 注意这里一定要加，不然在登录的时候会一直重定向。
        proxy_set_header   X-Forwarded-Proto $scheme;

        proxy_pass https://www.hamflx.cn;
    }
}
</code></pre>
<h2 id="配置邮箱"><a class="header" href="#配置邮箱">配置邮箱</a></h2>
<p>这里并不使用 <code>WP-SMTP</code> 类似的插件，而是通过“<code>My Custom Functions</code>”插件来实现这个功能。这个插件与邮箱功能无关，但是可以插入代码到 <code>WordPress</code>，这里只需要写一个邮箱功能初始化的函数插入到 <code>WordPress</code> 即可。</p>
<p>但是启用邮箱之后，激活邮件和重置密码邮件中的链接点击都无效，这是 <code>WordPress</code> 的一个 <code>BUG</code>。代码中的 <code>h_mail_filter</code> 函数即是为解决这个问题的。</p>
<p>在开始之前你需要一个具有 <code>SMTP</code> 功能的邮件服务器用来发送邮件，如果没有可以使用 <code>QQ</code> 邮箱。</p>
<h2 id="配置清单"><a class="header" href="#配置清单">配置清单</a></h2>
<p>在 <code>My Custom Functions</code> 插件中的 <code>Settings</code> 页面中加入如下代码：</p>
<pre><code class="language-php">function h_override_mail_from_name($email) {
    return '幻梦';
}

function h_override_mail_from($email) {
    return 'service@hamflx.cn';
}

function h_mail_filter($args) {
    $args['message'] = preg_replace(&quot;/&lt;(.*?)&gt;/&quot;, &quot;$1&quot;, $args['message']);
    return $args;
}

function h_mail_smtp($phpmailer) {
    $phpmailer-&gt;IsSMTP();
    $phpmailer-&gt;SMTPAuth = true;
    $phpmailer-&gt;Port = 465;
    $phpmailer-&gt;SMTPSecure = &quot;ssl&quot;;
    $phpmailer-&gt;Host = &quot;smtp.qq.com&quot;;
    $phpmailer-&gt;Username = &quot;service@hamflx.cn&quot;;
    $phpmailer-&gt;Password = &quot;Your Token&quot;;
}

add_filter('wp_mail_from_name', 'h_override_mail_from_name');
add_filter('wp_mail_from', 'h_override_mail_from');
add_filter('wp_mail', 'h_mail_filter');

add_action(&quot;phpmailer_init&quot;, &quot;h_mail_smtp&quot;);
</code></pre>
<h2 id="启用-qq-邮箱-smtp-功能"><a class="header" href="#启用-qq-邮箱-smtp-功能">启用 QQ 邮箱 SMTP 功能</a></h2>
<p>若使用 <code>QQ</code> 邮箱，则需要启用 <code>QQ</code> 邮箱的 <code>SMTP</code> 功能并生成授权码（作为 <code>SMTP</code> 登录时的密码）。</p>
<p>在 <code>QQ</code> 邮箱的设置页面中进入到“账户”选项卡，找到下图的配置，启用“<code>POP3/SMTP</code>”服务、生成授权码。</p>
<h2 id="参考资料-1"><a class="header" href="#参考资料-1">参考资料</a></h2>
<ul>
<li><a href="https://leonax.net/p/6391/implement-wordpress-email-notification-myself/">自己动手实现 WordPress 的邮件通知功能</a></li>
<li><a href="https://www.jerryzone.cn/diy-wp-email-content/">WordPress中各种邮件内容及标题的自定义</a></li>
<li><a href="https://www.cnblogs.com/kenshinobiy/p/7441781.html">完美解决wordpress邮件链接无效的问题</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="记一次内存泄漏的排查过程"><a class="header" href="#记一次内存泄漏的排查过程">记一次内存泄漏的排查过程</a></h1>
<p><code>JavaScript</code> 是有垃圾回收机制的，一般不太需要考虑资源释放的问题。然而，即使有垃圾回收兜底，但是代码写的太过于奔放，仍然存在不小的问题。这篇文章就以 <code>********</code> 排查出的问题做个简单介绍（注：<code>********</code> 为内部项目名称，下同）。</p>
<h2 id="检查是否存在内存泄漏"><a class="header" href="#检查是否存在内存泄漏">检查是否存在内存泄漏</a></h2>
<p>有用户反馈在 <code>********</code> 使用过程中，偶尔会出现浏览器崩溃的问题，然后在一次发版本的过程中，<code>****</code> 发现了内存占用达到了 <code>1GB</code> 程度，如下图（截图是后来截的，嫌麻烦就点到 <code>579MB</code>，多点几次总是能到 <code>1GB</code> 的 😏）：</p>
<p><img src="posts/2021/1/24/./assets/large-memory.png" alt="内存占用" title="内存占用" /></p>
<p>不过这 <code>579MB</code> 是正常内存占用，还是内存泄漏了呢？很简单，如果在使用过程中，内存占用未增加，或增加的都能在一段时间后（<code>GC</code> 执行了之后）正常释放掉，都是没有问题，但是如果在使用的过程中，内存一直增长而从未减少，即存在内存泄漏。</p>
<p>通过开发者工具里面的 <code>Memory</code> 面板，即可看到内存占用，使用 <code>Heap snapshot</code> 工具对内存占用做快照，在一顿猛烈的操作之前以及之后，分别做快照，然后对比一下就可以知道有没有内存泄漏了。</p>
<p>以 <code>********</code> 举例详细说下步骤：</p>
<ol>
<li>弄清楚你要排查哪一步可能存在内存泄漏，比如我需要排查 <code>A</code> 与 <code>B</code> 页面<strong>来回切换时</strong>，是否存在内存泄漏；</li>
<li>先打开 <code>********</code> 的 B 页面<strong>等待加载完毕</strong>，因为如果你切换快了，可能也会造成内存泄漏（比方说，在接口返回后添加事件），这里要<strong>一步步</strong>排查，就是控制变量法）；</li>
<li>然后<strong>切换到 A 页面</strong>，做快照之前要<strong>先</strong>把目标页面<strong>加载一次</strong>，因为“冷启动”也是要消耗资源的；</li>
<li>再切换回 B 页面，在 <code>Memory</code> 面板中选择 <code>Heap snapshot</code> 然后点 <code>Take snapshot</code> 做初始的快照（做快照之前要点击一次 <code>GC</code> 按钮，参照下图）；</li>
<li>点击 A 页面 =&gt; 点击 B 页面 =&gt; 点击 A 页面 =&gt; 点击 B 页面，反正就是一顿操作就是了，注意<strong>手速</strong>，<strong>不要</strong>把其他<strong>不确定因素</strong>引入进来；</li>
<li>最后停留在做<strong>初始内存快照</strong>的页面，这里是 B 页面，然后再做一个内存快照（别忘了先点 <code>GC</code> 按钮）；</li>
<li>对比一下两个数字就好了，如果没有太大差距的话，显然是没有内存泄漏的（当然，为了避免误判，你可以多重复几次第 <code>5</code> 步的操作），否则，存在内存泄漏。</li>
</ol>
<p><img src="posts/2021/1/24/./assets/devtools-memory-panel.png" alt="Memory 面板" title="Memory 面板" /></p>
<p>下面是 <code>********</code> 的（当然是点了很多很多次才会有这个数据的 🤣）：</p>
<p><img src="posts/2021/1/24/./assets/memory-snapshots.png" alt="内存快照" title="内存快照" /></p>
<h2 id="排查问题根源"><a class="header" href="#排查问题根源">排查问题根源</a></h2>
<p><img src="posts/2021/1/24/./assets/memory-snapshot-summary.png" alt="内存快照" title="内存快照" /></p>
<p>拿出上面步骤的第二个快照（图片里只有一个是因为我把第一个删了），展开 <code>a</code>（就是 <code>VueComponent</code>，经验），可以看到第一个 <code>a</code> 的“三围”：</p>
<ul>
<li><code>Distance</code> 14 被引用的深度，表示由 <code>GC</code> 根（比如 <code>window</code> 对象、DOM 数根节点）到该对象之间最短的引用数量。</li>
<li><code>Shallow Size</code> 浅层大小，该对象本身的大小。</li>
<li><code>Reatined Size</code> 保留大小，表示如果当前对象被释放后，所有的从 <code>GC</code> 根无法达到的对象的总的大小，简单点说，释放了这个对象，能释放多少内存。</li>
</ul>
<p>我们主要关注 <code>Distance</code> 和 <code>Reatined Size</code>，前者如果较大，我们可能就要关注一下这个对象是不是有问题。比如第一个 <code>a</code> 对象，鼠标悬浮 <code>a @8001491</code> 后，能看到该对象的数据：</p>
<p><img src="posts/2021/1/24/./assets/memory-snapshot-first-a-detail.png" alt="内存快照-第一个a对象" title="内存快照-第一个a对象" /></p>
<p>发现它是一个 <code>Vue</code> 组件的实例，鼠标悬浮到 <code>$el</code> 的值上面，如果这个元素仍然在页面上且是可见的，它就会像审查元素时一样覆盖一层蓝色矩形区域，显然这个没有（可以再展开其属性，看看 <code>isConnected</code>、<code>className</code>、<code>innerHTML</code> 了解具体是哪里的逻辑，以及是否从 <code>DOM</code> 树上移除了，这里的这个实例是一个表格组件）。而它的 <code>Retained Size</code> 则表示了，如果把这个对象给释放了，可以释放约 <code>1MB</code> 2% 的内存。</p>
<p>点击这个对象可以看到由该对象到 <code>GC</code> 根的引用关系：</p>
<p><img src="posts/2021/1/24/./assets/memory-snapshot-detail.png" alt="内存快照" title="内存快照" /></p>
<p>这张图说明：这个表格组件是另一个 <code>a</code>（<code>VueComponent</code>）组件的 <code>$parent</code> 属性，即作为另一个组件的父组件而被引用了，串联起来就是，这个表格组件被子组件引用了，子组件又被子组件引用了而子组件又被子组件引用了，而这个子组件又被一个方法引用了（这个方法使用 <code>bind</code> 绑定了这个组件），这个方法又被作为一个 <code>DOM</code> 元素的事件被引用了，而这个 <code>DOM</code> 元素又被 <code>InternalNode</code> 引用了，这个 <code>InternalNode</code> 属于 <code>HTMLDocument</code>。</p>
<p>即，这个表格里面有个组件添加了事件，但是组件销毁的时候没有把事件移除，所以，这个元素泄漏了，导致整个表格泄漏了。</p>
<p>将鼠标悬浮到 <code>bound_this in native_bind() @7606219</code> 上，可以看到：</p>
<p><img src="posts/2021/1/24/./assets/memory-snapshot-first-a-event.png" alt="内存快照" title="内存快照" /></p>
<p>找到了这个被添加而没有被移除的事件叫 <code>handleBlur</code>。OK，你现在是不是想全局搜索 <code>handleBlur</code> 方法了？</p>
<p><img src="posts/2021/1/24/./assets/found-handle-blur.png" alt="内存快照" title="内存快照" /></p>
<p>还真搜到了。。。不过，这样太麻烦了，可以看看这个 <code>bind</code> 绑定的到底是哪个组件，也就是鼠标悬浮这个上面的那一条记录 <code>$parent in a @9400441</code>，可以看到：</p>
<p><img src="posts/2021/1/24/./assets/memory-snapshot-first-a-dep-detail.png" alt="内存快照" title="内存快照" /></p>
<p>通过审查这个对象的 <code>$el</code> 可以知道，这是一个 <code>el-popover</code> 组件，也就是说 <code>el-popover</code> 监听了 <code>handleBlur</code> 事件，但是却没有移除，打开 <code>element</code> 仓库在 <code>packages\popover\src\main.vue</code> 中搜索 <code>handleBlur</code>：</p>
<p><img src="posts/2021/1/24/./assets/element-popover-handle-blur.png" alt="内存快照" title="内存快照" /></p>
<p>可以看到，只添加了该事件，而没有移除该事件。</p>
<h2 id="修复内存泄漏问题"><a class="header" href="#修复内存泄漏问题">修复内存泄漏问题</a></h2>
<p><code>Google</code> 搜索 <code>el-popover 内存泄漏</code>，然后复制、粘贴，<code>over</code>。不对，搜索结果第一条是：</p>
<blockquote>
<p>el-popover leaking memory · Issue #2561 · ElemeFE/element ...</p>
</blockquote>
<p>2017 年的 <code>Issue</code>，点开一看，对应的 <code>PR</code> 已经合并了，而且是点击事件，不是 <code>focusout</code> 事件，难道是定位错了？其实用 <code>el-tooltip 内存泄漏</code>、<code>el-popover memory leak</code> 为关键字搜索是可以搜索到 <a href="https://github.com/ElemeFE/element/issues/19370" title="[Bug Report] Memory leak at el-tooltip cleanup">[Bug Report] Memory leak at el-tooltip cleanup</a>，提这个 <code>bug</code> 的仁兄还提了两个 <code>PR</code> 修复 <code>el-tooltip</code>，还有位仁兄也提了 <code>PR</code> 修复 <code>el-tooltip</code> 和 <code>el-popover</code>，然而。。。</p>
<p>为了修复这个问题，而不克隆 <code>element</code> 仓库，我们可以重写对应的方法，这里我拿 <code>el-tooltip</code> 举例，原版的 <code>el-tooltip</code> 的 <code>mounted</code> 代码如下：</p>
<pre><code class="language-javascript">export default {
    // code ...

    mounted() {
        this.referenceElm = this.$el;
        if (this.$el.nodeType === 1) {
            this.$el.setAttribute('aria-describedby', this.tooltipId);
            this.$el.setAttribute('tabindex', this.tabindex);
            on(this.referenceElm, 'mouseenter', this.show);
            on(this.referenceElm, 'mouseleave', this.hide);
            on(this.referenceElm, 'focus', () =&gt; {
                if (!this.$slots.default || !this.$slots.default.length) {
                    this.handleFocus();
                    return;
                }
                const instance = this.$slots.default[0].componentInstance;
                if (instance &amp;&amp; instance.focus) {
                    instance.focus();
                } else {
                    this.handleFocus();
                }
            });
            on(this.referenceElm, 'blur', this.handleBlur);
            on(this.referenceElm, 'click', this.removeFocusing);
        }
    },

    // code ...

    destroyed() {
        const reference = this.referenceElm;
        if (reference.nodeType === 1) {
            off(reference, 'mouseenter', this.show);
            off(reference, 'mouseleave', this.hide);
            // 这里移除了 handleBlur 方法，但是前面添加的不是这个方法。。。
            off(reference, 'focus', this.handleFocus);
            off(reference, 'blur', this.handleBlur);
            off(reference, 'click', this.removeFocusing);
        }
    }
}
</code></pre>
<p>通过如下方法重新实现它的相关方法：</p>
<pre><code class="language-javascript">import { Tooltip } from 'element-ui'
import { on } from 'element-ui/lib/utils/dom'

Tooltip.methods.handleFocus = function () {
  if (!this.$slots.default || !this.$slots.default.length) {
    this.doFocus()
    return
  }
  const instance = this.$slots.default[0].componentInstance
  if (instance &amp;&amp; instance.focus) {
    instance.focus()
  } else {
    this.doFocus()
  }
}

Tooltip.methods.doFocus = function () {
  this.focusing = true
  this.show()
}

Tooltip.mounted = function () {
  this.referenceElm = this.$el
  if (this.$el.nodeType === 1) {
    this.$el.setAttribute('aria-describedby', this.tooltipId)
    // 这行代码在 Element 上的提交日志是为了无障碍访问，这将导致测试提一些 bug（点击空白处关闭详情页后，文字的 tooltip 仍然显示）。
    // this.$el.setAttribute('tabindex', 0)
    on(this.referenceElm, 'mouseenter', this.show)
    on(this.referenceElm, 'mouseleave', this.hide)
    on(this.referenceElm, 'focus', this.handleFocus)
    on(this.referenceElm, 'blur', this.handleBlur)
    on(this.referenceElm, 'click', this.removeFocusing)
  }
}

export default {
  install () {

  }
}
</code></pre>
<p>即，将原来直接添加的事件，写成 <code>handleFocus</code> 方法（原来也有这个方法，故把原来的 <code>handleFocus</code> 方法改为 <code>doFocus</code> 方法，然后在 <code>handleFocus</code> 方法里调用，这样其 <code>destroyed</code> 里面释放的事件就是添加的事件了。</p>
<h2 id="其他问题"><a class="header" href="#其他问题">其他问题</a></h2>
<p>通过同样的方式，还可以找到定时器未释放、点击事件未释放之类的问题，但都是项目内的代码，比较好解决就不展开了。</p>
<h2 id="成果"><a class="header" href="#成果">成果</a></h2>
<p><img src="posts/2021/1/24/./assets/result.png" alt="内存快照" title="内存快照" /></p>
<h2 id="深入思考"><a class="header" href="#深入思考">深入思考</a></h2>
<p>不知道大家有没有注意，搜索中文的 <code>el-popover</code> 内存泄漏没有搜索到想要的结果，其实不移除事件一般也是可以的，而且不会造成内存泄漏，所以一般情况下比较难以发现这个问题。</p>
<p>现代浏览器都是用 <code>标记</code>-<code>清除</code> 算法或基于其改进的算法来实现的垃圾回收。其原理是从 <code>GC</code> 根开始，遍历所有引用的对象，并将其标记，当算法遍历完所有对象后，那些未被标记的对象将会被清除。</p>
<p>而 <code>Vue.js</code> 会在组件被销毁的时候，释放其引用，那么其引用的元素，以及元素引用的事件都将成为无根浮萍，会被 <code>GC</code> 回收。</p>
<p>再次审查上文中的表格组件，可以发现 <code>V8EventListener</code> 被 <code>Detached HTMLElement</code> 引用，而 <code>Detached HTMLElement</code> 又被 <code>InternalNode</code> 引用，这个 <code>InternalNode</code> 才是它没有被释放的真正原因。</p>
<p>至于这个 <code>InternalNode</code> 究竟是什么，我们 <code>N</code> 期之后再说（<code>N → ∞</code>）。</p>
<h2 id="参考资料-2"><a class="header" href="#参考资料-2">参考资料</a></h2>
<ul>
<li><a href="https://developers.google.com/web/tools/chrome-devtools/memory-problems/memory-101?hl=zh-cn" title="内存术语">内存术语</a></li>
<li><a href="https://developers.google.com/web/tools/chrome-devtools/memory-problems/heap-snapshots?hl=zh-cn" title="如何记录堆快照">如何记录堆快照</a></li>
<li><a href="https://github.com/ElemeFE/element/issues/19370" title="[Bug Report] Memory leak at el-tooltip cleanup">[Bug Report] Memory leak at el-tooltip cleanup</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management" title="内存管理">内存管理</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="增强-vue-项目的智能感知"><a class="header" href="#增强-vue-项目的智能感知">增强 <code>Vue</code> 项目的智能感知</a></h1>
<p>本文说的类型支持仅仅是 <code>VS Code</code> 的 <code>IntelliSense</code> 功能，并非静态类型语言的类型检查，所以对开发的效率提升不大，但是可以提高项目的可维护性，即所谓代码即文档 <code>CaaD</code>（<code>Code as a Documentation</code> -_-）。</p>
<h2 id="vs-code-的-intellisense-功能"><a class="header" href="#vs-code-的-intellisense-功能"><code>VS Code</code> 的 <code>IntelliSense</code> 功能</a></h2>
<p>使用过 <code>IDE</code> 与静态类型语言的同学可能很熟悉了，比如 <code>VS</code>/<code>C#</code> 的自动导入命名空间、<code>Code Refactor</code>（重命名属性/方法/类名等标识符，并自动修改所有的引用）、转到定义（转到声明、查找引用）甚至代码段提取（提取一段代码作为一个函数，并自动将依赖的变量作为参数输入）等各种强大的功能。</p>
<p>而 <code>JS</code> 是一个动态类型的语言，为了支持上述功能，<code>VS Code</code> 团队开发了一个插件，名为 <code>Visual Studio IntelliCode</code>，最早该插件是作为一个外部扩展，后来直接作为内部扩展，可以直接使用。</p>
<p>以下摘自官网描述：</p>
<blockquote>
<p>IntelliSense is a general term for a variety of code editing features including: code completion, parameter info, quick info, and member lists. IntelliSense features are sometimes called by other names such as &quot;code completion&quot;, &quot;content assist&quot;, and &quot;code hinting.&quot;</p>
</blockquote>
<p>蹩脚翻译如下：</p>
<blockquote>
<p>智能感知是一系列编码特性的统称，包括自动补全、参数提示、快捷信息以及成员提示。……</p>
</blockquote>
<p><strong>特别注意</strong>：在成员提示被关闭的情况下可以使用快捷键 <code>Ctrl</code>+<code>Space</code> 重新打开成员提示（极大的可能与 <code>Windows</code> 系统默认的输入法切换键冲突导致失效，此时可以考虑更换快捷键），与 <code>Ctrl</code>+<code>Shift</code>+<code>Space</code> 打开参数提示。</p>
<h2 id="配置-jsconfigjson"><a class="header" href="#配置-jsconfigjson">配置 <code>jsconfig.json</code></a></h2>
<p>首先要说的是 <code>jsconfig.json</code> 文件。用 <code>vue</code> 脚手架生成的项目中，并无该文件，且一般情况下没有该文件也会有 <code>IntelliSense</code> 功能。</p>
<p>这里配置 <code>jsconfig.json</code> 的必要原因是：</p>
<ol>
<li>无该文件会导致项目内的 <code>.d.ts</code> 文件不一定被加载；</li>
<li>对于 <code>Vue</code> 项目来说，导入时使用 <code>@</code> 是很常见的行为，但是这将会导致 <code>IntelliSense</code> 无法识别。</li>
</ol>
<p>一个常见的 <code>jsconfig.json</code> 配置如下：</p>
<pre><code class="language-json">{
  &quot;compilerOptions&quot;: {
    &quot;baseUrl&quot;: &quot;.&quot;,
    &quot;paths&quot;: {
      &quot;@/*&quot;: [
        &quot;src/*&quot;
      ]
    }
  },
  &quot;include&quot;: [
    &quot;./src/**/*.d.ts&quot;,
    &quot;./src/**/*.js&quot;,
    &quot;./src/**/*.vue&quot;
  ]
}
</code></pre>
<p>这个 <code>jsconfig.json</code> 包含了对导入时 <code>@</code> 的解析以及扫描项目 <code>src</code> 目录及其子目录下的 <code>.d.ts</code>、<code>.js</code>、<code>.vue</code> 文件，以建立类型、引用等相关信息（转到定义、查找引用以及自动导入的关键）。</p>
<p>配置完成后重新加载（<code>Ctrl</code>+<code>Shift</code>+<code>P</code> 输入 <code>Reload Window</code> 并回车）即可。此时输入 <code>import '@/'</code> 后会有路径提示（如果没有可能是还没有加载完成，耐心等待一会儿 -.-）。</p>
<p><img src="posts/2020/11/13/./vsc-vue-intelli-sense/import-list.png" alt="导入提示" /></p>
<p>值得注意的是，导入 <code>SFC</code> 文件时，文件的路径必须添加 <code>.vue</code> 后缀：</p>
<pre><code class="language-javascript">import FieldEdit from '@/components/FieldEdit.vue'
</code></pre>
<p>这样的话你就可以将光标移动到组件名称上按下 <code>F12</code> 键以导航到组件的定义，否则是无法导航到组件定义的，你会看到这样的提示：</p>
<p><img src="posts/2020/11/13/./vsc-vue-intelli-sense/component-not-found.png" alt="导航失败" /></p>
<p>另外，配置完成后，还可以在 <code>&lt;template&gt;</code> 标签中得到自定义组件的补全提示，如果没有导入，甚至可以在敲回车补全时自动导入：</p>
<p><img src="posts/2020/11/13/./vsc-vue-intelli-sense/component-list.png" alt="导航失败" /></p>
<p>至于提示的组件的命名方式可以在此处配置，具体每个选项都有描述就不说了：</p>
<p><img src="posts/2020/11/13/./vsc-vue-intelli-sense/tag-casing.png" alt="规则配置" /></p>
<h2 id="jsdoc-注释"><a class="header" href="#jsdoc-注释"><code>JSDoc</code> 注释</a></h2>
<p>即使用注释来说明代码。在 <code>VS Code</code> 中可以通过在 <code>js</code> 类型的文件中输入 <code>/**</code> 来触发 <code>JSDoc</code> 代码片段，以下是一些实例：</p>
<pre><code class="language-javascript">/**
 * 引用数据额外的信息发生了变化的事件。
 */
const EVENT_ISSUE_INFO_CHANGE = 'issue-info-change'

/**
 * 所属的应用类型 ID。
 */
const ISSUE_TYPE = {
  /** 需求。 */
  REQUIREMENT: 1,
  /** 任务。 */
  TASK: 2
}

/**
 * 将一个字符串反过来。
 * @param {string} str 需要反转的字符串。
 * @returns {string} 反转后的字符串。
 */
function reverseString (str) {
  return str.split('').reverse().join('')
}
</code></pre>
<p>这种注释可以提供如下的效果，在成员提示的列表中可以显示注释内容，即做到文档的效果（同时鼠标悬浮时也会有文档的提示）：</p>
<p><img src="posts/2020/11/13/./vsc-vue-intelli-sense/member-list.png" alt="成员提示" /></p>
<p><img src="posts/2020/11/13/./vsc-vue-intelli-sense/function-annote.png" alt="函数声明" /></p>
<p>可以看到，第二张图标注了传入参数 <code>str</code> 的类型，在输入 <code>str.sp</code> 时会给予成员提示，敲回车键后即会自动完成。</p>
<h2 id="类型声明文件"><a class="header" href="#类型声明文件">类型声明文件</a></h2>
<p>类型声明文件是一个 <code>.d.ts</code> 文件，使用过 <code>Type Script</code> 的同学应该不陌生，在使用 <code>Type Script</code> 开发库项目时，如果需要发布到 <code>npm</code> 仓库，则需要编译成 <code>js</code> 发布，并可以用 <code>tsc</code> 生成对应的类型声明文件，以供使用者参照。</p>
<p>对于没有 <code>Type Script</code> 的 <code>Vue</code> 项目，仍然可以使用 <code>.d.ts</code> 文件带来的部分便利，虽然需要手写 <code>.d.ts</code> 文件。</p>
<p>一个 <code>.d.ts</code> 文件的例子如下：</p>
<pre><code class="language-typescript">/**
 * 应用数据的模型。
 */
declare type IssueModel = {
  /**
   * 应用数据的属性字典。
   */
  dataMap: {
    [key in IssuePropertyNames]: IssueProperty
  }

  /**
   * 可编辑的属性名称列表。
   */
  editablePropertyList: string[]
}

/**
 * 应用数据的数据属性名称列表。
 */
declare type IssuePropertyNames =
  'id' |
  'issuetype' |
  'key' |
  'project' |
  'summary' |
  'description'

/**
 * 应用数据的属性定义。
 */
declare interface IssueProperty {
  /**
   * 属性的名称。
   */
  name: string

  /**
   * 属性值的可读形式。
   */
  label: string

  /**
   * 属性值。
   */
  value: PropertyValue
}

/**
 * 属性值的类型。
 */
declare type PropertyValue = boolean | number | string | boolean[] | number[] | string[]
</code></pre>
<p>上述代码并不会生成 <code>js</code> 代码，仅仅在开发期间被编辑器或集成开发环境识别以用作代码自动完成、成员提示等功能。在数据结构较为复杂时，可以利用类型声明文件作为文档以提高项目的可维护性。</p>
<p>虽然类型声明文件不参与 <code>js</code> 代码的执行，但是仍然可以利用类型声明文件影响到 <code>js</code> 代码的编写，将上述类型声明文件保存后，即可在 <code>js</code> 代码中以 <code>JSDoc</code> 的形式引用：</p>
<pre><code class="language-javascript">/**
 * 应用数据模型。
 * @type {IssueModel}
 */
const model = {
  dataMap: {
    issuetype: {
      value: ISSUE_TYPE.REQUIREMENT
    }
  }
}

console.log(model.dataMap.issuetype.value)
</code></pre>
<p>效果如下：</p>
<p><img src="posts/2020/11/13/./vsc-vue-intelli-sense/object-definition-member-list.png" alt="对象成员" /></p>
<p><img src="posts/2020/11/13/./vsc-vue-intelli-sense/object-ref-member-list.png" alt="对象成员" /></p>
<h2 id="sfc-的成员类型"><a class="header" href="#sfc-的成员类型"><code>SFC</code> 的成员类型</a></h2>
<pre><code class="language-vue">&lt;template&gt;
  &lt;div&gt;
    &lt;input v-model=&quot;value&quot; @blur=&quot;handleInputBlur&quot; /&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  props: {
    /**
     * 应用数据模型。
     * @type {import('vue').PropOptions&lt;IssueModel&gt;}
     */
    model: {
      type: Object,
      required: true
    },
    /**
     * 需要编辑的字段。
     * @type {import('vue').PropOptions&lt;IssuePropertyNames&gt;}
     */
    property: {
      type: String,
      required: true
    }
  },
  data () {
    return {
      value: this.model.dataMap[this.property].value,
      /**
       * @type {IssueModel}
       */
      other: {}
    }
  },
  methods: {
    /**
     * 获取属性值。
     * @param {IssueModel} issue 应用数据模型。
     * @param {IssuePropertyNames} property 属性名称。
     * @returns {PropertyValue} 属性值。
     */
    getPropertyValue (issue, property) {
      issue.dataMap[property].value
    },
    handleInputBlur () {
      this.$emit('submit', this.model, this.property, this.value)
    }
  }
}
&lt;/script&gt;
</code></pre>
<p>上面分别标记了 <code>props</code>、<code>data</code>、<code>methods</code> 的数据类型、参数及返回值，在引用这些属性、变量时，将会有自动完成提示、参数信息等：</p>
<p><img src="posts/2020/11/13/./vsc-vue-intelli-sense/vue-member-list.png" alt="对象成员" /></p>
<p><img src="posts/2020/11/13/./vsc-vue-intelli-sense/vue-method-param.png" alt="对象成员" /></p>
<h2 id="自动导入功能"><a class="header" href="#自动导入功能">自动导入功能</a></h2>
<p>在引用一些常用的导出符号时，如果这个符号没有被导入，则可以在打开的成员提示中找到这个标识符，并键入回车完成自动补全，这个时候会自动导入这个标识符：</p>
<p><img src="posts/2020/11/13/./vsc-vue-intelli-sense/auto-import.png" alt="对象成员" /></p>
<p>在提示信息中说明了 <code>Import 'ISSUE_TYPE' from module &quot;@/constatns/issueType&quot;</code>，键入回车即可自动导入该标识符。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vuedraggable-使用问题记录"><a class="header" href="#vuedraggable-使用问题记录"><code>vuedraggable</code> 使用问题记录</a></h1>
<ul>
<li>本文引用的 <code>Sortable.js</code> 源码 <code>commit id</code> 为：<code>1dff5e1</code></li>
<li>本文引用的 <code>vuedraggable</code> 源码 <code>commit id</code> 为：<code>2fd91d6</code></li>
</ul>
<p><code>vuedraggable</code> 官方地址：<a href="https://sortablejs.github.io/Vue.Draggable/">https://sortablejs.github.io/Vue.Draggable/</a></p>
<p><code>vuedraggable</code> 是一个封装了 <code>Sortable.js</code> 的 <code>vue</code> 组件，将拖动同步到对应的数据模型上，提供了 <code>Sortable.js</code> 的所有特性。</p>
<p>但是 <code>vuedraggable</code> 提供的 <code>vue</code> 组件对动态绑定的属性并不能较好的兼容，会引发一些莫名奇妙的问题。</p>
<p>考虑一个典型的拖动场景，有待办、进行及完成三个泳道，每个泳道里面有若干卡片，待办中的卡片可以拖动到进行的泳道，反之进行的卡片则无法拖动到待办的泳道，若要在拖动时，高亮显示可以放置的泳道，则可以在 <code>start</code> 事件记录下拖动的卡片，通过双向绑定设置是否可以放置的类名 <code>is-droppable</code>。</p>
<pre><code class="language-html">&lt;!-- is-droppable 用于设置拖动时，可以放置的样式，在拖动过程中，isLaneDroppable 将会返回 true，否则为 false --&gt;
&lt;div :class=&quot;{ 'is-droppable': isLaneDroppable(item) }&quot;&gt;
    &lt;Draggable :sort=&quot;false&quot;&gt;
        &lt;div&gt;&lt;/div&gt;
    &lt;/Draggable&gt;
&lt;/div&gt;
</code></pre>
<p>在这种 <code>draggable</code> 组件的父级元素绑定了动态属性的情况下，会导致 <code>sort</code> 属性不生效，初步猜测是 <code>DOM</code> 结构更新后，<code>Sortable.js</code> 未能匹配上，导致 <code>sort</code> 的判断失效。</p>
<p>因此，在使用 <code>draggable</code> 时，<strong>最好不要在拖动的过程中，修改动态绑定的属性的值，避免拖动时更新 <code>DOM</code></strong>。</p>
<p>避免使用双向绑定，同时再配合 <code>start</code> 事件，在该事件中找到所有可以放置的泳道，并通过直接操作 <code>DOM</code> 的形式，给可以放置的元素添加 <code>is-droppable</code> 类名可以解决该问题。</p>
<p>在该场景上考虑另一个问题，若需要在拖动时，当前鼠标悬停的、可放置的泳道上设置一个有别于可放置的样式（比方说，可放置是虚线边框，悬停的是实现边框且有背景色），基于先前的经验避开使用双向绑定的方法，直接使用 <code>move</code> 事件操作对应的 <code>DOM</code>，添加 <code>is-target</code> 类名。</p>
<p>此时会有一个新的问题，当 <code>:sort=&quot;false&quot;</code> 触发时（即，鼠标移动到原泳道但非卡片原位置，将会触发拖动的重置，此时卡片的占位符将会回到拖动前的位置），将不会触发 <code>move</code> 事件，即，悬停高亮将没办法更新，还是为原先设置的元素高亮。</p>
<p>检查 <code>Sortable.js</code> 源码的 <code>1287-1306</code> 行：</p>
<pre><code class="language-typescript">if (revert) {
    parentEl = rootEl; // actualization
    capture();

    this._hideClone();

    //@ts-ignore
    dragOverEvent(&quot;revert&quot;);

    //@ts-ignore
    if (!Sortable.eventCanceled) {
        if (nextEl) {
        rootEl.insertBefore(dragEl, nextEl);
        } else {
        rootEl.appendChild(dragEl);
        }
    }

    return completed(true);
}
</code></pre>
<p>可知，在拖动被重置时，会触发 <code>revert</code> 事件，检查 <code>dragOverEvent</code> 函数的定义可知，这是一个在插件上触发的事件，而非 <code>Sortable.js</code> 实例事件，因此，可以编写一个插件，监听该事件，并将该事件在实例上触发，便可以解决该问题。</p>
<p>检查 <code>vuedraggable</code> 源代码的第 <code>197-228</code> 行：</p>
<pre><code class="language-javascript">mounted() {
    // ...

    !(&quot;draggable&quot; in options) &amp;&amp; (options.draggable = &quot;&gt;*&quot;);
    this._sortable = new Sortable(this.rootContainer, options);
    this.computeIndexes();
},
</code></pre>
<p>可以使用以下的方法获取内部的 <code>Sortable.js</code> 引用：</p>
<pre><code class="language-javascript">import Vue from 'vue'
import Draggable from 'vuedraggable'

const Tmp = Vue.extend(Draggable)
const tmp = new Tmp().$mount()
const Sortable = tmp._sortable.constructor
</code></pre>
<p>参考 <code>on-spill</code> 插件，可以编写出如下的插件：</p>
<pre><code class="language-javascript">function RevertEventPlugin () {}

RevertEventPlugin.prototype = {
  constructor: RevertEventPlugin,
  revertGlobal ({ dispatchSortableEvent }) {
    dispatchSortableEvent('revert')
  }
}

Object.assign(RevertEventPlugin, {
  pluginName: 'revertEventPlugin'
})
</code></pre>
<p>将以上两部封装为一个模块，用于替代 <code>vuedraggable</code> 模块：</p>
<pre><code class="language-javascript">/*
 * 描述：返回一个可以触发 revert 事件的 vuedraggable 组件
 * 文件名：src/utils/vuedraggableWithRevert.js
 */

import Vue from 'vue'
import Draggable from 'vuedraggable'

function RevertEventPlugin () {}

RevertEventPlugin.prototype = {
  constructor: RevertEventPlugin,
  revertGlobal ({ dispatchSortableEvent }) {
    dispatchSortableEvent('revert')
  }
}

Object.assign(RevertEventPlugin, {
  pluginName: 'revertEventPlugin'
})

const getDraggableWithRevertEvent = () =&gt; {
  const Tmp = Vue.extend(Draggable)
  const tmp = new Tmp().$mount()
  const Sortable = tmp._sortable.constructor
  Sortable.mount(RevertEventPlugin)
  return Draggable
}

export default getDraggableWithRevertEvent()
</code></pre>
<p>在使用时，直接将 <code>import Draggable from 'vuedraggable'</code> 替换为 <code>import Draggable from './src/utils/vuedraggableWithRevert'</code> 即可，若需要监听 <code>revert</code> 事件，添加一个具有 <code>onRevert</code> 属性的 <code>options</code>。</p>
<pre><code class="language-html">&lt;Draggable
    :sort=&quot;false&quot;
    :options=&quot;{ onRevert: handleCardItemRevert }&quot;
/&gt;
&lt;/Draggable&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="玩饥荒联机版日志"><a class="header" href="#玩饥荒联机版日志">玩饥荒联机版日志</a></h1>
<h2 id="搭建独立服务器"><a class="header" href="#搭建独立服务器">搭建独立服务器</a></h2>
<ol>
<li>
<p>安装 <code>SteamCMD</code>。首先创建 <code>steam</code> 用户，然后下载 <code>SteamCMD</code>：<a href="https://steamcdn-a.akamaihd.net/client/installer/steamcmd_linux.tar.gz">https://steamcdn-a.akamaihd.net/client/installer/steamcmd_linux.tar.gz</a> 解压安装，安装位置任意，详细步骤及依赖关系推荐参阅此处。</p>
</li>
<li>
<p>运行 <code>steamcmd.sh</code></p>
</li>
<li>
<p>登陆并安装服务器：</p>
<pre><code class="language-shell">login anonymous
force_install_dir /home/steam/dstserver
app_update 343050
validate
quit
</code></pre>
</li>
<li>
<p>配置服务器。可在 <code>Windows</code> 上使用图形界面启动具有洞穴的服务器，然后清除该存档记录并将其复制到 <code>/home/steam/.klei/DoNotStarveTogether</code> 目录中即可。也可以先将存档复制到上述目录，然后使用下述脚本清除存档：</p>
<pre><code class="language-shell"># 其中 /home/steam/.klei/DoNotStarveTogether/GlxinWorld 为世界存档目录
rm -rf /home/steam/.klei/DoNotStarveTogether/GlxinWorld/{Master,Caves}/save
</code></pre>
</li>
<li>
<p>启动服务器。</p>
<pre><code class="language-shell"># 必须进入该目录，否则可能会无法加载
# 其中 Cluster_1 改为对应的存档名称
cd /home/steam/dstserver/bin
./dontstarve_dedicated_server_nullrenderer -console -cluster Cluster_1 -shard Caves
./dontstarve_dedicated_server_nullrenderer -console -cluster Cluster_1 -shard Master
</code></pre>
</li>
</ol>
<p>Tip：有些系统（如：<code>CentOS 7</code>）不提供 <code>libcurl-gnutls.so.4</code> 那么将其链接到 <code>libcurl.so.4</code> 即可。</p>
<p>多世界并存：若要在一台服务器上运行多个饥荒服务器，则需要修改存档的 <code>Master</code> 及 <code>Caves</code> 目录中 <code>server.ini</code> 的 <code>server_port</code> 使其各不相同，且在 <code>10998-11018</code> 范围内。且每个存档的 <code>cluster.ini</code> 中 <code>master_port</code> 应唯一，该端口用于存档的地面与洞穴之间通信。 饥荒服务器在启动时同样会监听 <code>127.0.0.1:10888/UDP</code> 端口和一个非固定 <code>TCP</code> 端口，可能这些也需要修改。初步猜测该端口可能用于存档的地面与洞穴之间通信，多个存档应修改该端口。</p>
<p>跨服务器世界：即将洞穴服务器与地面服务器分离，将存档的 <code>cluster.ini</code> 中 <code>master_ip</code> 与 <code>master_port</code> 配置为地面服务器的 IP 地址和端口即可。</p>
<h2 id="一键启动脚本"><a class="header" href="#一键启动脚本">一键启动脚本</a></h2>
<p>其中变量按需修改，若不希望每次启动都检查更新，将脚本中检查更新的行注释即可。另外，最新版不购买可能导致搜素不到世界的问题，故可以按照下一节介绍安装 <code>247691</code> 版本。</p>
<pre><code class="language-shell">#!/bin/bash

steamcmd_dir=&quot;$HOME/Steam&quot;
install_dir=&quot;$HOME/dstserver&quot;
cluster_name=&quot;GlxinWorld&quot;
dontstarve_dir=&quot;$HOME/.klei/DoNotStarveTogether&quot;

function fail()
{
        echo Error: &quot;$@&quot; &gt;&amp;2
        exit 1
}

function check_for_file(){
    if [ ! -e &quot;$1&quot; ]; then
            fail &quot;Missing file: $1&quot;
    fi
}

cd &quot;$steamcmd_dir&quot; || fail &quot;Missing $steamcmd_dir directory!&quot;
check_for_file &quot;$steamcmd_dir/steamcmd.sh&quot;
check_for_file &quot;$dontstarve_dir/$cluster_name/cluster.ini&quot;
check_for_file &quot;$dontstarve_dir/$cluster_name/cluster_token.txt&quot;
check_for_file &quot;$dontstarve_dir/$cluster_name/Master/server.ini&quot;
check_for_file &quot;$dontstarve_dir/$cluster_name/Caves/server.ini&quot;

# 检查更新，若不需要每次启动都检查更新，将其注释即可
~/Steam/steamcmd.sh +force_install_dir &quot;$install_dir&quot; +login anonymous +app_update 343050 validate +quit

check_for_file &quot;$install_dir/bin&quot;

cd &quot;$install_dir/bin&quot; || fail
run_shared=(./dontstarve_dedicated_server_nullrenderer)
run_shared+=(-console)
run_shared+=(-cluster &quot;$cluster_name&quot;)
run_shared+=(-monitor_parent_process $$)

&quot;${run_shared[@]}&quot; -shard Caves  | sed 's/^/Caves:  /' &amp;
&quot;${run_shared[@]}&quot; -shard Master | sed 's/^/Master: /'
</code></pre>
<h2 id="下载指定版本"><a class="header" href="#下载指定版本">下载指定版本</a></h2>
<ol>
<li>进入 <code>SteamDB</code> 查找游戏，记录 <code>AppID</code>。</li>
<li>进入 <code>Depots</code> 找到对应平台，记录 <code>DepotID</code>。</li>
<li>点击 <code>DepotID</code> =&gt; <code>Manifests</code> 找到需要的版本，记录 <code>ManifestID</code>。</li>
<li><code>Windows</code> 下运行 <code>steam://nav/console</code> 进入控制台/<code>Linux</code> 下执行 <code>steamcmd.sh</code>。</li>
<li>若是 <code>Linux</code> 用户，需要执行 <code>login anonymous</code> 登陆；若不是 <code>Linux</code> 用户则跳过。</li>
<li>执行 <code>download_depot &lt;AppID&gt; &lt;DepotID&gt; &lt;ManifestID&gt;</code> 进行下载。</li>
<li>执行 <code>quit</code> 退出。</li>
</ol>
<p>若下载失败，可退出从第 4 步重新开始。实际测试发现，下载成功率非常低，故建议使用外网服务器，且具有不低的带宽。</p>
<p>上述过程得到 DST 的信息如下：</p>
<ul>
<li>AppID: 343050</li>
<li>Linux DepotID: 343052</li>
<li>Latest Version ManifestID: 3637127330667398786</li>
<li>Version 247691 ManifestID: 6994825278996354537</li>
<li>SteamDB URL: <a href="https://steamdb.info/app/343050/">https://steamdb.info/app/343050/</a></li>
</ul>
<p>进入控制台（<code>Win + R</code> 运行）:</p>
<pre><code class="language-shell">steam://nav/console
</code></pre>
<p>下载 <code>247691</code> 版本游戏：</p>
<pre><code class="language-shell">download_depot 343050 343052 6994825278996354537
</code></pre>
<p><code>Linux</code> 可在控制台直接执行：</p>
<pre><code class="language-shell">steamcmd.sh +login anonymous +download_depot 343050 343052 6994825278996354537 +quit
</code></pre>
<p><code>SteamCMD</code> 根据游戏 <code>depot id</code> 进行存储，故一个游戏可下载多个 <code>depot</code> 对应的版本，但每个 <code>depot</code> 仅能下载一个 <code>manifest</code> 对应的版本。</p>
<h2 id="参考资料-3"><a class="header" href="#参考资料-3">参考资料</a></h2>
<p><a href="https://gist.github.com/xPaw/fe7d275d31da14d70481">steam_commands</a>
<a href="https://developer.valvesoftware.com/wiki/SteamCMD">SteamCMD – Valve Developer Community</a>
<a href="https://blessing.studio/deploy-dont-starve-together-dedicated-server/">饥荒联机版独立服务器搭建踩坑记录 – Blessing Studio</a>
<a href="https://steamcn.com/t258082-1-1">【社区指南翻译】如何下载旧版的游戏 – 平台研讨 – SteamCN 蒸汽动力 – 驱动正版游戏的引擎！</a>
<a href="https://steamcn.com/t258079-1-1">通过depot下载得到旧版游戏及一个衍生应用 – 平台研讨 – SteamCN 蒸汽动力 – 驱动正版游戏的引擎！</a>
<a href="https://www.reddit.com/r/Steam/comments/611h5e/guide_how_to_download_older_versions_of_a_game_on/">Guide: How to download older versions of a game on Steam：Steam</a>
<a href="http://blog.ttionya.com/article-1235.html">饥荒联机独立服务器搭建教程（三）：配置篇 | 天天の記事簿</a>
<a href="https://unix.stackexchange.com/questions/267118/create-udp-to-tcp-bridge-with-socat-netcat-to-relay-control-commands-for-vlc-med">Create UDP to TCP bridge with socat/netcat to relay control commands for vlc media-player – Unix &amp; Linux Stack Exchange</a></p>
<h2 id="playing-outside-the-lan"><a class="header" href="#playing-outside-the-lan">Playing outside the LAN</a></h2>
<p>对游戏端口 <code>UDP 10998/10999</code> 进行转发，可实现在外网进入内网的游戏服务器。其简单 <code>python2</code> 脚本如下：</p>
<p>agent_v3.py：</p>
<pre><code class="language-python">#!/usr/bin/env python2
# -*- coding: utf-8 -*-

&quot;&quot;&quot;
Usage:
    agent.py -h | --help
    agent.py client [-p BASE_PORT]
    agent.py server [-p BASE_PORT]

Options:
    -h --help                       show this
    -p BASE_PORT, --port BASE_PORT  specify base port

Examples:
    agent.py client

&quot;&quot;&quot;


from threading import Thread
from docopt import docopt
from time import sleep
from socket import socket, AF_INET, SOCK_DGRAM

LOCALHOST_IP = '127.0.0.1'
MASTER_IP_ADDRESS = '172.18.135.5'
MASTER_PORT = 10999
CAVES_IP_ADDRESS = '172.18.135.5'
CAVES_PORT = 10998

BASE_TRANSFER_PORT = 10001

BUFFER_SIZE = 10485760


def remote_to_local(sock_local, sock_remote, addr, buffsize):
    while True:
        data = sock_remote.recv(buffsize)
        if len(data):
            sock_local.sendto(data, )
    pass


def local_to_remote(local, remote, buffsize):
    conn_dict = {}
    sock_local = socket(AF_INET, SOCK_DGRAM)
    sock_local.bind(local)
    sock_remote = None
    while True:
        data, addr = sock_local.recvfrom(buffsize)
        if addr in conn_dict:
            sock_remote = conn_dict[addr]
        else:
            sock_remote = socket(AF_INET, SOCK_DGRAM)
            sock_remote.connect(remote)
            Thread(target=remote_to_local, args=(sock_local, sock_remote, addr, buffsize))
        sock_remote.sendall(data)


def build_connection(local, remote, buffsize):
    thread = Thread(target=local_to_remote, args=(local, remote, buffsize))
    thread.setDaemon(True)
    thread.start()


def check_connection(conns):
    for conn in conns:
        if not conn['t_l2r'].isAlive():
            return False
        if not conn['t_r2l'].isAlive():
            return False
    return True


def main(client_mode, base_port):
    master_listen, master_remote = None, None
    caves_listen, caves_remote = None, None
    if client_mode:
        master_listen = ('0.0.0.0', MASTER_PORT)
        master_remote = (MASTER_IP_ADDRESS, base_port)
        caves_listen = ('0.0.0.0', CAVES_PORT)
        caves_remote = (CAVES_IP_ADDRESS, base_port + 1)
    else:
        master_listen = ('0.0.0.0', base_port)
        master_remote = (LOCALHOST_IP, MASTER_PORT)
        caves_listen = ('0.0.0.0', base_port + 1)
        caves_remote = (LOCALHOST_IP, CAVES_PORT)
    conns = []
    conns.append(build_connection(master_listen, master_remote, BUFFER_SIZE))
    conns.append(build_connection(caves_listen, caves_remote, BUFFER_SIZE))

    try:
        while check_connection(conns):
            sleep(1)
    except KeyboardInterrupt as e:
        print 'User interrupted'

    return None


if __name__ == '__main__':
    arguments = docopt(__doc__)
    main(arguments['client'], int(arguments['--port'] or BASE_TRANSFER_PORT))
</code></pre>
<p>脚本依赖 docopt。</p>
<p>forward_v1.py：</p>
<pre><code class="language-python">#!/usr/bin/python2
# coding: utf-8


import sys

from time import sleep
from Queue import Queue
from select import select
from socket import socket, AF_INET, SOCK_DGRAM, SOL_SOCKET, SO_REUSEADDR

# 512KB
BUFFER_SIZE = 524288

LEVEL_INFO = 0
LEVEL_ERROR = 1


def log(level, text):
    if level == LEVEL_ERROR:
        print text


def do_forwarding(options):
    sock_remote = socket(AF_INET, SOCK_DGRAM)
    sock_remote.setblocking(False)
    sock_remote.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)
    sock_remote.bind(options[&quot;bind&quot;])

    connections = {}

    inputs = [sock_remote]
    outputs = []
    msg_queues = []

    while True:
        try:
            readable, writable, exceptional = select(inputs, outputs, [], 0.1)
        except KeyboardInterrupt:
            break
        if not (readable or writable or exceptional):
            continue
        for sock in readable:
            try:
                data, address = sock.recvfrom(BUFFER_SIZE)
            except Exception, ex:
                log(LEVEL_ERROR, 'Error: ' + repr(ex))
            if len(data) == 0:
                continue
            log(LEVEL_INFO, 'Received from: ' + repr(address))
            sleep
            if sock is sock_remote:
                if address in connections:
                    sock_out = connections[address]
                    log(LEVEL_INFO, 'Host already exists: ' + repr(address))
                else:
                    sock_out = socket(AF_INET, SOCK_DGRAM)
                    sock_out.connect(options[&quot;host&quot;])
                    connections[address] = sock_out
                    inputs.append(sock_out)
                    log(LEVEL_INFO, 'Added remote host: ' + repr(address))
                addr_out = options[&quot;host&quot;]
            else:
                for src_addr, src_sock in connections.iteritems():
                    if src_sock is sock:
                        addr_out = src_addr
                sock_out = sock_remote
            msg_queues.append({ &quot;to&quot;: addr_out, &quot;sock&quot;: sock_out, &quot;data&quot;: data })
            outputs.append(sock_out)
            log(LEVEL_INFO, 'Add sock to output list: ' + repr(sock_out.getsockname()))
        for sock in writable:
            log(LEVEL_INFO, 'Sock want to send data: ' + repr(sock.getsockname()))
            remains_msgs = []
            for msg in msg_queues:
                if msg[&quot;sock&quot;] is sock:
                    log(LEVEL_INFO, 'Hint message')
                    try:
                        sock.sendto(msg[&quot;data&quot;], msg[&quot;to&quot;])
                        log(LEVEL_INFO, 'Sent to: ' + repr(msg[&quot;to&quot;]) + ' via: ' + repr(sock.getsockname()))
                    except Exception, ex:
                        log(LEVEL_ERROR, 'Error: ' + repr(ex))
                else:
                    remains_msgs.append(msg)
            msg_queues = remains_msgs
        if writable:
            outputs = []

    for addr, sock in connections.iteritems():
        sock.close()
    sock_remote.close()


def parse_arguments(args):
    if len(args) != 2:
        return None
    params = args[1].split(':')
    options = { &quot;agent_port&quot;: 12345 }
    if len(params) == 3:
        options[&quot;bind&quot;] = &quot;127.0.0.1&quot;, int(params[0])
        options[&quot;host&quot;] = params[1], int(params[2])
    elif len(params) == 4:
        options[&quot;bind&quot;] = params[0], int(params[1])
        options[&quot;host&quot;] = params[2], int(params[3])
    else:
        return None
    return options


def usage():
    print &quot;Usage: forward.py [bind_ip:]bind_port:host_ip:host_port&quot;
    exit(1)


def main():
    options = parse_arguments(sys.argv)
    if options:
        do_forwarding(options)
    else:
        usage()


if __name__ == '__main__':
    main()
</code></pre>
<p><code>Server</code> 端监听需要转发的端口，并接受多条连接，建立表维护连接信息，在接收到数据时连带连接信息发送给连接到 <code>Server</code> 端的 <code>Client</code> 端。</p>
<h2 id="问题-1"><a class="header" href="#问题-1">问题</a></h2>
<p>在启动 <code>dontstarve_dedicated_server_nullrenderer</code> 进程时，可能遇到如下错误：</p>
<ul>
<li>
<p><code>[S_API FAIL] SteamAPI_Init() failed; SteamAPI_IsSteamRunning() failed.</code> 忽略即可。</p>
</li>
<li>
<p><code>Segmentation fault (core dumped)</code> 可能是游戏中的 <code>steamclient.so</code> 库文件与 <code>SteamCMD</code> 中的 <code>steamclient.so</code> 文件版本不匹配导致。删除该文件，并将 <code>SteamCMD</code> 中的该文件链接到游戏中该文件。</p>
<pre><code class="language-shell"># 将游戏中的 steamclient.so 备份为 steamclient.so.bak 后将 SteamCMD 中的 steamclient.so 链接到游戏中对应的位置
# 下面命令假定 SteamCMD 安装在 /home/steam/Steam，饥荒联机版安装在 /home/steam/dstserver
cd /home/steam/dstserver/bin/lib32 mv steamclient.so{,.bak}
ln -s /home/steam/SteamCMD/linux32/steamclient.so /home/steam/dstserver/bin/lib32/steamclient.so
# 若无法解决问题，则可以通过如下命令恢复
mv /home/steam/dstserver/bin/lib32/steamclient.so.bak /home/steam/dstserver/bin/lib32/steamclient.so
</code></pre>
<p>若运行上述命令解决问题后，则应将世界启动脚本中的更新指令移除。若不移除，游戏的更新、校验都会将上述修改覆盖，从而导致游戏无法运行。</p>
<pre><code class="language-shell"># 在脚本中找到下面这一行，并将其注释
#~/Steam/steamcmd.sh +force_install_dir &quot;$install_dir&quot; +login anonymous +app_update 343050 validate +quit
</code></pre>
</li>
</ul>
<h2 id="backup--restore"><a class="header" href="#backup--restore">Backup &amp; Restore</a></h2>
<h3 id="backup"><a class="header" href="#backup">Backup</a></h3>
<pre><code class="language-shell"># 进入存档目录
cd /home/steam/.klei/DoNotStarveTogether/GlxinWorld

# 建立存档备份目录
mkdir ../backup

# 执行备份
zip -r ../backup.$(date +%Y%m%d%H%M%S).zip .
</code></pre>
<h3 id="restore"><a class="header" href="#restore">Restore</a></h3>
<pre><code class="language-shell"># 进入存档目录
cd /home/steam/.klei/DoNotStarveTogether/GlxinWorld

# 列出存档列表，并找出需要恢复的存档
ls ../backup

# 恢复存档
find . -delete &amp;&amp; unzip ../backup/backup.20180614173011.zip
</code></pre>
<h3 id="automatically-backup"><a class="header" href="#automatically-backup">Automatically backup</a></h3>
<p>在基于 Systemd 的 Linux 系统上，创建如下两个文件实现每 3h 对存档做一次备份。由于在游戏运行状态中，存档目录会包含许多临时文件，</p>
<p><code>/usr/lib/systemd/system/dst-backup.service</code>：</p>
<pre><code class="language-conf">[Unit]
Description=Don't Starve Together Backup

[Service]
Type=oneshot
ExecStart=/bin/bash -c 'cd /home/steam/.klei/DoNotStarveTogether/GlxinWorld &amp;&amp; zip -r ../backup/backup.$(date +%%Y%%m%%d%%H%%M%%S).zip .'
User=steam
</code></pre>
<p><code>/usr/lib/systemd/system/dst-auto-backup.timer</code>：</p>
<pre><code class="language-conf">[Unit]
Description=Don't Starve Together Auto Backup

[Timer]
OnUnitActiveSec=3h
Unit=dst-backup.service

[Install]
WantedBy=multi-user.target
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chrome-时代的浏览器兼容性测试"><a class="header" href="#chrome-时代的浏览器兼容性测试">Chrome 时代的浏览器兼容性测试</a></h1>
<p>对于这个标题，我想有一些人是很有疑惑的，对于 <code>IE</code> 时代来说，确实需要去研究浏览器的兼容性，但是对于浏览器中的老大 <code>Chrome</code>，我们需要考虑它的兼容性吗？</p>
<p>就我目前做的项目，目标用户都是使用 <code>Chrome</code> 浏览器，但是仍然在工作中碰到很多关于 <code>Chrome</code> 的问题，比如：</p>
<ul>
<li>用户反馈你们的软件开了一天就卡的不行，有时候半天不到就会崩溃，然后你吭哧吭哧去解决内存泄漏的点，然后自己测试发现没问题，但是一上线，客户又反馈卡卡卡（浏览器内存泄漏）；</li>
<li>用户机器上，表格的渲染有时缺一某一条边框，有时候有的边框特别粗；</li>
<li>明明没有设置 <code>z-index</code>，或者设置了较小的 <code>z-index</code>，但是滚动到容器下面的时候，被遮住的那部分滚动条却突破了容器显示出来了；</li>
<li>开发时没考虑 <code>API</code> 兼容性，用了 <code>replaceAll</code>，然后在用户机器上挂掉了；</li>
<li>因为要嵌入第三方页面，考虑到 <code>Chrome</code> 变更了 <code>SameSite</code> 策略，默认为 <code>None</code>，需要兼容新旧版本的 <code>Chrome</code>；</li>
<li><code>Chrome</code> 删除了 <code>/deep/</code> 的支持，导致项目中错误使用 <code>/deep/</code> 的地方样式崩溃；</li>
<li><code>Chrome</code> 在某个版本删除了 <code>Event.path</code> 的支持，然后用这个的地方也都崩了。</li>
</ul>
<p>上述情况有些是属于 <code>bug</code>，有些是浏览器更新太快而开发人员知识没有跟上，还有些就是单纯的开发人员的失误。</p>
<p>像 <code>Event.path</code> 实际上是一个非标准属性，在 <code>Chrome 100</code> 上还可以正常使用，在 <code>Chrome 101</code> 的时候，如果你使用这个属性，会在 <code>Issues</code> 里输出一个 <code>Deprecated Feature Used</code> 的警告。然后在 <code>Chrome 104</code> 里就不能用了。然而你高强度开发的时候，真的会在意这个警告吗？</p>
<p>所以，浏览器的兼容性问题一直都在，只不过，从兼容 <code>IE</code> 变换为兼容老版本 <code>Chrome</code> 和兼容新版本 <code>Chrome</code>，以及兼容特定版本 <code>Chrome</code>。</p>
<p>因此，你可能会需要频繁的下载不同版本的 <code>Chrome</code> 来做各种兼容性测试，这之前对我来说是个比较麻烦的事，我不喜欢通过第三方网站下载的安装包，通过官方 <code>Chromium</code> 给出的方法又太麻烦。</p>
<p>后来无意间看到这个仓库：<a href="https://github.com/google/fetchchromium">google/fetchchromium</a>，但是这个工具需要提供 <code>revision</code>，不能通过版本号下载，然后我就自己搞了一个 <a href="https://github.com/hamflx/fetchbrowser">hamflx/fetchbrowser</a>，可以通过给定版本号下载特定的 <code>Chromium</code> 浏览器，另外，也支持下载 <code>Firefox</code>。</p>
<h2 id="fetchbrowser"><a class="header" href="#fetchbrowser">fetchbrowser</a></h2>
<p>仓库地址：<a href="https://github.com/hamflx/fetchbrowser">https://github.com/hamflx/fetchbrowser</a>，欢迎 <code>star</code> (❁´◡`❁)。</p>
<p>安装方式：</p>
<pre><code class="language-powershell">irm https://raw.githubusercontent.com/hamflx/fetchbrowser/master/install.ps1 | iex
</code></pre>
<p>下载 <code>Chromium 98</code>：</p>
<pre><code class="language-powershell">fb 98
</code></pre>
<p><strong>注意：在特定平台第一次下载 <code>Chromium</code> 会比较慢，因为会联机查找版本信息，后续会使用缓存的数据。</strong></p>
<p>下载 <code>Chromium 109.0.5414.120</code>：</p>
<pre><code class="language-powershell">fb 109.0.5414.120
</code></pre>
<p>下载 <code>Firefox 98</code>：</p>
<pre><code class="language-powershell">fb --firefox 98
</code></pre>
<p>对 <code>Firefox</code> 的支持可能会有问题，因为 <code>Firefox</code> 官方只提供了安装包的安装形式，这里是下载了官方的安装包后解压实现的。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
                <script>
                
                    document.body.querySelector('main').insertAdjacentHTML('beforeend', `
                        <div id="disqus_thread"></div>
                    `);
                    /**
                    *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
                    *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables    */
                
                    var disqus_config = function () {
                    this.page.url = undefined;  // Replace PAGE_URL with your page's canonical URL variable
                    this.page.identifier = 'print.md'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
                    };
                
                    (function() { // DON'T EDIT BELOW THIS LINE
                    var d = document, s = d.createElement('script');
                    s.src = 'https://hamflx-blog.disqus.com/embed.js';
                    s.setAttribute('data-timestamp', +new Date());
                    (d.head || d.body).appendChild(s);
                    })();
                </script>
                <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                
                <!-- Global site tag (gtag.js) - Google Analytics -->
                <script async src="https://www.googletagmanager.com/gtag/js?id=G-8V723V89LY"></script>
                <script>
                  window.dataLayer = window.dataLayer || [];
                  function gtag(){dataLayer.push(arguments);}
                  gtag('js', new Date());
                
                  gtag('config', 'G-8V723V89LY');
                </script>
                
                <div class="icp">
                  <a class="icp-link" href="https://beian.miit.gov.cn/" target="_blank">皖ICP备16015010号-2</a>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
